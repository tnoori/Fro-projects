(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova["default"])()) {
        return (0, _readAsByteArray["default"])(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error("Unknown data type");
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative["default"])() && input && typeof input.uri !== "undefined") {
        return (0, _uriToBlob["default"])(input.uri).then(function (blob) {
          return new FileSource(blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. " + err);
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === "function" && typeof input.size !== "undefined") {
        return Promise.resolve(new FileSource(input));
      }

      if (typeof input.read === "function") {
        chunkSize = +chunkSize;

        if (!isFinite(chunkSize)) {
          return Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
        }

        return Promise.resolve(new StreamSource(input, chunkSize));
      }

      return Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
    }
  }]);

  return FileReader;
}();

exports["default"] = FileReader;

},{"./isCordova":5,"./isReactNative":6,"./readAsByteArray":7,"./uriToBlob":8}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */


function fingerprint(file, options) {
  if ((0, _isReactNative["default"])()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(["tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint].join("-"));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint].join("/");
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}

},{"./isReactNative":6}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return "XHRHttpStack";
    }
  }]);

  return XHRHttpStack;
}();

exports["default"] = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!("upload" in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function get() {
    return _logger.enableDebugLog;
  }
});
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function get() {
    return _urlStorage.canStoreURLs;
  }
});
exports.isSupported = exports.defaultOptions = exports.Upload = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/* global window */


var defaultOptions = _objectSpread({}, _upload["default"].defaultOptions, {
  httpStack: new _httpStack["default"](),
  fileReader: new _fileReader["default"](),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage["default"](),
  fingerprint: _fingerprint["default"]
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread({}, defaultOptions, {}, options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread({}, defaultOptions, {}, options);
      return _upload["default"].terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload["default"]);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === "function";
exports.isSupported = isSupported;

},{"../logger":11,"../noopUrlStorage":12,"../upload":13,"./fileReader":1,"./fingerprint":2,"./httpStack":3,"./urlStorage":9}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isCordova = function isCordova() {
  return typeof window != "undefined" && (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined");
};

var _default = isCordova;
exports["default"] = _default;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};

var _default = isReactNative;
exports["default"] = _default;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = readAsByteArray;
/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */

function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uriToBlob;
/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */

function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = "blob";

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open("GET", uri);
    xhr.send();
  });
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebStorageUrlStorage = exports.canStoreURLs = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window, localStorage */


var hasStorage = false;

try {
  hasStorage = "localStorage" in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = "tusSupport";
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries("tus::");

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  return function () {
    var Super = _getPrototypeOf(Derived),
        result;

    if (_isNativeReflectConstruct()) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader("X-Request-ID") || "n/a";
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : "n/a";
      var body = res ? res.getBody() || "" : "n/a";
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return DetailedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports["default"] = _default;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;
/* eslint no-console: "off" */

var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports["default"] = NoopUrlStorage;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _error = _interopRequireDefault(require("./error"));

var _uuid = _interopRequireDefault(require("./uuid"));

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _logger = require("./logger");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/* global window */


var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ("resume" in options) {
      console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
        this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ["uploadUrl", "uploadSize", "uploadLengthDeferred"].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.");
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        } else {
          return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
        }
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      var totalSize = this._size = this._source.size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread({}, _this3.options, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread({}, _this3.options.headers, {
                "Upload-Concat": "partial"
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return !!u;
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest("POST", _this3.options.endpoint);
        req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" "))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== "") {
          req.setHeader("Upload-Metadata", metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this3._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;

        if (isNaN(this._size)) {
          this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.url));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)("Creating a new upload");

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate, cb) {
      var _this4 = this;

      if (typeof cb === "function") {
        throw new Error("tus: the abort function does not accept a callback since v2 anymore; please use the returned Promise instead");
      } // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error["default"](message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));

        return;
      }

      var req = this._openRequest("POST", this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader("Upload-Defer-Length", 1);
      } else {
        req.setHeader("Upload-Length", this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== "") {
        req.setHeader("Upload-Metadata", metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");

          return;
        }

        var location = res.getHeader("Location");

        if (location == null) {
          _this6._emitHttpError(req, res, "tus: invalid or missing Location header");

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === "function") {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, "tus: failed to create upload", err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest("HEAD", this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader("Upload-Offset"), 10);

        if (isNaN(offset)) {
          _this7._emitHttpError(req, res, "tus: invalid or missing offset value");

          return;
        }

        var length = parseInt(res.getHeader("Upload-Length"), 10);

        if (isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, "tus: invalid or missing length value");

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === "function") {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest("POST", this.url);
        req.setHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        req = this._openRequest("PATCH", this.url);
      }

      req.setHeader("Upload-Offset", this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset " + _this8._offset, err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader("Content-Type", "application/offset+octet-stream"); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader("Upload-Length", _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        } else {
          _this9._emitProgress(_this9._offset, _this9._size);

          return _this9._sendRequest(req, value);
        }
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader("Upload-Offset"), 10);

      if (isNaN(offset)) {
        this._emitHttpError(req, res, "tus: invalid or missing offset value");

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        return _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body while invoking the onBeforeRequest
     * and onAfterResponse callbacks.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var _this12 = this;

      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (typeof this.options.onBeforeRequest === "function") {
        this.options.onBeforeRequest(req);
      }

      return req.send(body).then(function (res) {
        if (typeof _this12.options.onAfterResponse === "function") {
          _this12.options.onAfterResponse(req, res);
        }

        return res;
      });
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 ? arguments[2] : undefined;

      if (typeof options === "function" || typeof cb === "function") {
        throw new Error("tus: the terminate function does not accept a callback since v2 anymore; please use the returned Promise instead");
      }

      var req = openRequest("DELETE", url, options);
      var promise = req.send();
      return promise.then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error["default"]("tus: unexpected response while terminating upload", null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error["default"])) {
          err = new _error["default"]("tus: failed to terminate upload", err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread({}, options, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + _jsBase.Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader("Tus-Resumable", "1.0.0");
  var headers = options.headers || {};

  for (var name in headers) {
    req.setHeader(name, headers[name]);
  }

  if (options.addRequestId) {
    var requestId = (0, _uuid["default"])();
    req.setHeader("X-Request-ID", requestId);
  }

  return req;
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== "undefined" && "navigator" in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. no a status 4xx or a 409 or 423) and
  // - the browser does not indicate that we are offline
  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;
  return options.retryDelays != null && retryAttempt < options.retryDelays.length && err.originalRequest != null && isServerError && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse["default"](link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports["default"] = _default;

},{"./error":10,"./logger":11,"./uuid":14,"js-base64":47,"url-parse":51}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uuid;
/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */

function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

},{}],15:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":17}],16:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/createError":23,"./../core/settle":26,"./../helpers/buildURL":30,"./../helpers/cookies":32,"./../helpers/isURLSameOrigin":34,"./../helpers/parseHeaders":36,"./../utils":38}],17:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":18,"./cancel/CancelToken":19,"./cancel/isCancel":20,"./core/Axios":21,"./defaults":28,"./helpers/bind":29,"./helpers/spread":37,"./utils":38}],18:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],19:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":18}],20:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],21:[function(require,module,exports){
'use strict';

var defaults = require('./../defaults');
var utils = require('./../utils');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"./../defaults":28,"./../utils":38,"./InterceptorManager":22,"./dispatchRequest":24}],22:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":38}],23:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":25}],24:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var isAbsoluteURL = require('./../helpers/isAbsoluteURL');
var combineURLs = require('./../helpers/combineURLs');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":20,"../defaults":28,"./../helpers/combineURLs":31,"./../helpers/isAbsoluteURL":33,"./../utils":38,"./transformData":27}],25:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

},{}],26:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":23}],27:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":38}],28:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this,require('_process'))

},{"./adapters/http":16,"./adapters/xhr":16,"./helpers/normalizeHeaderName":35,"./utils":38,"_process":44}],29:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],30:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":38}],31:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],32:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);

},{"./../utils":38}],33:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],34:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);

},{"./../utils":38}],35:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":38}],36:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":38}],37:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],38:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');
var isBuffer = require('is-buffer');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":29,"is-buffer":39}],39:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

},{}],40:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":41,"ieee754":42,"isarray":43}],41:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],42:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],43:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],44:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],45:[function(require,module,exports){
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":46}],46:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":44}],47:[function(require,module,exports){
(function (global){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    var _Base64 = global.Base64;
    var version = "2.4.9";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = eval("require('buffer').Buffer");
        } catch (err) {
            buffer = undefined;
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/[\s\S]{1,4}/g, cb_decode);
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        __buffer__: buffer
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],48:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],49:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],50:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],51:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":48,"requires-port":50}],52:[function(require,module,exports){
"use strict";

require("regenerator-runtime/runtime");

require("es6-promise/auto");

// The regenerator runtime is needed since the test use functions
// with the async/await keywords. See
// https://babeljs.io/docs/en/babel-plugin-transform-regenerator
// Polyfill `Promise` for Internet Explorer.
// This is a fun piece of code. Let me tell you the story behind it:
// Internet Explorer 10 and 11 have a bug where the event handlers
// for XMLHttpRequests will be invoked with a significant delay after
// the actual request has been finished. So, even if the HTTP request
// only took 1s to complete, IE will wait another 20s before it decides
// to tell your application that the request has been finished. This
// was not a big problem in daily use since this issue did only occur
// when the user did not interact with the webpage, e.g. move the mouse.
// However, when testing in automated browssers, no user interaction was
// occurring.
// Eventually, someone figured out that this was related to a Promise
// polyfill that is used by the axios HTTP client. This solution is
// to use a timeout, as follows, which is enough to cause the network
// delays to vanish.
// Whoever found that patch, I hope they will go to heaven.
// See https://github.com/axios/axios/issues/1862
function t() {
  window.setTimeout(t, 10);
}

t();
beforeEach(function () {
  // Clear localStorage before every test to prevent stored URLs to
  // interfere with our setup.
  localStorage.clear();
});

require("./helpers/puppeteer/reporter.js");

require("./test-common.js");

require("./test-browser-specific.js");

require("./test-parallel-uploads.js");

require("./test-terminate.js");

require("./test-end-to-end.js");

},{"./helpers/puppeteer/reporter.js":54,"./test-browser-specific.js":56,"./test-common.js":57,"./test-end-to-end.js":58,"./test-parallel-uploads.js":59,"./test-terminate.js":60,"es6-promise/auto":45,"regenerator-runtime/runtime":49}],53:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

module.exports = /*#__PURE__*/function () {
  var _assertUrlStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(urlStorage) {
    var result, key1, key2, key3;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return urlStorage.findAllUploads();

          case 2:
            result = _context.sent;
            expect(result).toEqual([]); // Add a few uploads into the storage

            _context.next = 6;
            return urlStorage.addUpload("fingerprintA", {
              id: 1
            });

          case 6:
            key1 = _context.sent;
            _context.next = 9;
            return urlStorage.addUpload("fingerprintA", {
              id: 2
            });

          case 9:
            key2 = _context.sent;
            _context.next = 12;
            return urlStorage.addUpload("fingerprintB", {
              id: 3
            });

          case 12:
            key3 = _context.sent;
            expect(/^tus::fingerprintA::/.test(key1)).toBe(true);
            expect(/^tus::fingerprintA::/.test(key2)).toBe(true);
            expect(/^tus::fingerprintB::/.test(key3)).toBe(true); // Query the just stored uploads individually

            _context.next = 18;
            return urlStorage.findUploadsByFingerprint("fingerprintA");

          case 18:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }]);
            _context.next = 23;
            return urlStorage.findUploadsByFingerprint("fingerprintB");

          case 23:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 3,
              urlStorageKey: key3
            }]); // Check that we can retrieve all stored uploads

            _context.next = 28;
            return urlStorage.findAllUploads();

          case 28:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }, {
              id: 3,
              urlStorageKey: key3
            }]); // Check that it can remove an upload and will not return it back

            _context.next = 33;
            return urlStorage.removeUpload(key2);

          case 33:
            _context.next = 35;
            return urlStorage.removeUpload(key3);

          case 35:
            _context.next = 37;
            return urlStorage.findUploadsByFingerprint("fingerprintA");

          case 37:
            result = _context.sent;
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }]);
            _context.next = 41;
            return urlStorage.findUploadsByFingerprint("fingerprintB");

          case 41:
            result = _context.sent;
            expect(result).toEqual([]);

          case 43:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function assertUrlStorage(_x) {
    return _assertUrlStorage.apply(this, arguments);
  }

  return assertUrlStorage;
}(); // Sort the results from the URL storage since the order in not deterministic.


function sort(result) {
  result.sort(function (a, b) {
    return a.id - b.id;
  });
}

},{}],54:[function(require,module,exports){
"use strict";

/* eslint no-console: 0 */

/* eslint no-unused-vars: 0 */
var testsCompleted = false;
var testsPassed = true; // This reporter is used by bin/puppeteer-jasmine.js to obtain the test results.
// See https://jasmine.github.io/api/edge/Reporter.html for more details on the
// function signatures.

var reporter = {
  jasmineStarted: function jasmineStarted(suiteInfo) {},
  suiteStarted: function suiteStarted(result) {},
  specStarted: function specStarted(result) {},
  specDone: function specDone(result) {
    // Print the test result to the console.
    var passed = result.status === "passed";
    var prefix = passed ? "" : "";
    console.log(prefix, result.fullName);
    testsCompleted = true;
    testsPassed = testsPassed && passed;

    for (var i = 0; i < result.failedExpectations.length; i++) {
      console.log("Failure: " + result.failedExpectations[i].message);
      console.log(result.failedExpectations[i].stack);
      console.log("");
    }
  },
  suiteDone: function suiteDone(result) {},
  jasmineDone: function jasmineDone(result) {
    var success = testsCompleted && testsPassed;

    if (success) {
      console.log("Tests passed!");
    } else {
      console.log("Tests failed!");
    } // The __jasmineCallback function is exposed by the bin/puppeteer-jasmine.js
    // script. See it for more details.


    if (typeof window.__jasmineCallback === "function") {
      window.__jasmineCallback(success);
    }
  }
};
window.jasmine.getEnv().addReporter(reporter);

},{}],55:[function(require,module,exports){
(function (Buffer){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var isBrowser = typeof window !== "undefined";
var isNode = !isBrowser;
/**
 * Obtain a platform specific buffer object, which can be
 * handled by tus-js-client.
 */

function getBlob(str) {
  if (isNode) {
    return Buffer.from(str);
  } else {
    return new Blob(str.split(""));
  }
}
/**
 * Create a promise and obtain the resolve/reject functions
 * outside of the Promise callback.
 */


function flatPromise() {
  var resolveFn;
  var rejectFn;
  var p = new Promise(function (resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return [p, resolveFn, rejectFn];
}
/**
 * Create a spy-able function which resolves a Promise
 * once it is called.
 */


function waitableFunction() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "func";

  var _flatPromise = flatPromise(),
      _flatPromise2 = _slicedToArray(_flatPromise, 2),
      promise = _flatPromise2[0],
      resolve = _flatPromise2[1];

  var fn = jasmine.createSpy(name, resolve).and.callThrough();
  fn.toBeCalled = promise;
  return fn;
}
/**
 * Create a Promise that resolves after the specified duration.
 */


function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay, "timed out");
  });
}
/**
 * TestHttpStack implements the HTTP stack interface for tus-js-client
 * and can be used to assert outgoing requests and respond with mock data.
 */


var TestHttpStack = /*#__PURE__*/function () {
  function TestHttpStack() {
    _classCallCheck(this, TestHttpStack);

    this._pendingRequests = [];
    this._pendingWaits = [];
  }

  _createClass(TestHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      var _this = this;

      return new TestRequest(method, url, function (req) {
        if (_this._pendingWaits.length >= 1) {
          var handler = _this._pendingWaits.shift();

          handler(req);
          return;
        }

        _this._pendingRequests.push(req);
      });
    }
  }, {
    key: "nextRequest",
    value: function nextRequest() {
      var _this2 = this;

      if (this._pendingRequests.length >= 1) {
        return Promise.resolve(this._pendingRequests.shift());
      }

      return new Promise(function (resolve) {
        _this2._pendingWaits.push(resolve);
      });
    }
  }]);

  return TestHttpStack;
}();

var TestRequest = /*#__PURE__*/function () {
  function TestRequest(method, url, onRequestSend) {
    _classCallCheck(this, TestRequest);

    this.method = method;
    this.url = url;
    this.requestHeaders = {};
    this.body = null;
    this._onRequestSend = onRequestSend;

    this._onProgress = function () {};

    var _flatPromise3 = flatPromise();

    var _flatPromise4 = _slicedToArray(_flatPromise3, 3);

    this._requestPromise = _flatPromise4[0];
    this._resolveRequest = _flatPromise4[1];
    this._rejectRequest = _flatPromise4[2];
  }

  _createClass(TestRequest, [{
    key: "getMethod",
    value: function getMethod() {
      return this.method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this.url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this.requestHeaders[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this.requestHeaders[header] || null;
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      this._onProgress = progressHandler;
    }
  }, {
    key: "send",
    value: function send() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.body = body;

      if (body) {
        this._onProgress(0);

        this._onProgress(body.length || body.size || 0);
      }

      this._onRequestSend(this);

      return this._requestPromise;
    }
  }, {
    key: "abort",
    value: function abort() {
      this._rejectRequest(new Error("request aborted"));
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error("not implemented");
    }
  }, {
    key: "respondWith",
    value: function respondWith(resData) {
      resData.responseHeaders = resData.responseHeaders || {};
      var res = new TestResponse(resData);

      this._resolveRequest(res);
    }
  }, {
    key: "responseError",
    value: function responseError(err) {
      this._rejectRequest(err);
    }
  }]);

  return TestRequest;
}();

var TestResponse = /*#__PURE__*/function () {
  function TestResponse(res) {
    _classCallCheck(this, TestResponse);

    this._response = res;
  }

  _createClass(TestResponse, [{
    key: "getStatus",
    value: function getStatus() {
      return this._response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._response.responseHeaders[header];
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._response.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error("not implemented");
    }
  }]);

  return TestResponse;
}();

module.exports = {
  TestHttpStack: TestHttpStack,
  waitableFunction: waitableFunction,
  wait: wait,
  getBlob: getBlob
};

}).call(this,require("buffer").Buffer)

},{"buffer":40}],56:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* global Blob  */
var assertUrlStorage = require("./helpers/assertUrlStorage");

var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait;

var tus = require("../../");

describe("tus", function () {
  beforeEach(function () {
    localStorage.clear();
  });
  describe("#Upload", function () {
    it("should resume an upload from a stored url", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, file, options, upload, previousUploads, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localStorage.setItem("tus::fingerprinted::1337", JSON.stringify({
                uploadUrl: "http://tus.io/uploads/resuming"
              }));
              testStack = new TestHttpStack();
              file = new Blob("hello world".split(""));
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onProgress: function onProgress() {},
                fingerprint: function fingerprint() {}
              };
              spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              _context.next = 9;
              return upload.findPreviousUploads();

            case 9:
              previousUploads = _context.sent;
              expect(previousUploads).toEqual([{
                uploadUrl: "http://tus.io/uploads/resuming",
                urlStorageKey: "tus::fingerprinted::1337"
              }]);
              upload.resumeFromPreviousUpload(previousUploads[0]);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalledWith(file, upload.options);
              _context.next = 16;
              return testStack.nextRequest();

            case 16:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 3
                }
              });
              _context.next = 23;
              return testStack.nextRequest();

            case 23:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(3);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              expect(upload.url).toBe("http://tus.io/uploads/resuming");
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    describe("storing of upload urls", function () {
      var testStack = new TestHttpStack();
      var options = {
        httpStack: testStack,
        endpoint: "http://tus.io/uploads",
        fingerprint: function fingerprint() {}
      };

      var startUpload = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var file, upload, req;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  file = new Blob("hello world".split(""));
                  spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
                  options.onSuccess = waitableFunction("onSuccess");
                  upload = new tus.Upload(file, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalled();
                  _context2.next = 8;
                  return testStack.nextRequest();

                case 8:
                  req = _context2.sent;
                  expect(req.url).toBe("http://tus.io/uploads");
                  expect(req.method).toBe("POST");
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: "/uploads/blargh"
                    }
                  }); // Wait a short delay to allow the Promises to settle

                  _context2.next = 14;
                  return wait(10);

                case 14:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function startUpload() {
          return _ref2.apply(this, arguments);
        };
      }();

      var finishUpload = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var req;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return testStack.nextRequest();

                case 2:
                  req = _context3.sent;
                  expect(req.url).toBe("http://tus.io/uploads/blargh");
                  expect(req.method).toBe("PATCH");
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      "Upload-Offset": 11
                    }
                  });
                  _context3.next = 8;
                  return options.onSuccess.toBeCalled;

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function finishUpload() {
          return _ref3.apply(this, arguments);
        };
      }();

      it("should store and retain with default options", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var key, storedUpload;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options.removeFingerprintOnSuccess = false;
                _context4.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf("tus::fingerprinted::")).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe("http://tus.io/uploads/blargh");
                expect(storedUpload.size).toBe(11);
                _context4.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(JSON.stringify(storedUpload));

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      })));
      it("should store and remove with option removeFingerprintOnSuccess set", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var key, storedUpload;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options.removeFingerprintOnSuccess = true;
                _context5.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf("tus::fingerprinted::")).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe("http://tus.io/uploads/blargh");
                expect(storedUpload.size).toBe(11);
                _context5.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(null);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      })));
    });
    it("should delete upload urls on a 4XX", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = new Blob("hello world".split(""));
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                fingerprint: function fingerprint() {}
              };
              spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                uploadUrl: "http://tus.io/uploads/resuming",
                urlStorageKey: "tus::fingerprinted::1337"
              });
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 400
              });
              _context6.next = 15;
              return wait(10);

            case 15:
              expect(localStorage.getItem("tus::fingerprinted::1337")).toBe(null);

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    describe("uploading data from a Reader", function () {
      function makeReader(content) {
        var readSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : content.length;
        var reader = {
          value: content.split(""),
          read: function read() {
            var value,
                done = false;

            if (this.value.length > 0) {
              value = this.value.slice(0, readSize);
              this.value = this.value.slice(readSize);
            } else {
              done = true;
            }

            return Promise.resolve({
              value: value,
              done: done
            });
          },
          cancel: waitableFunction("cancel")
        };
        return reader;
      }

      function assertReaderUpload(_x) {
        return _assertReaderUpload.apply(this, arguments);
      }

      function _assertReaderUpload() {
        _assertReaderUpload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(_ref7) {
          var readSize, chunkSize, reader, testStack, options, upload, req;
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  readSize = _ref7.readSize, chunkSize = _ref7.chunkSize;
                  reader = makeReader("hello world", readSize);
                  testStack = new TestHttpStack();
                  options = {
                    httpStack: testStack,
                    endpoint: "http://tus.io/uploads",
                    chunkSize: chunkSize,
                    onProgress: waitableFunction("onProgress"),
                    onSuccess: waitableFunction("onSuccess"),
                    fingerprint: function fingerprint() {},
                    uploadLengthDeferred: true
                  };
                  spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
                  upload = new tus.Upload(reader, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                  _context14.next = 10;
                  return testStack.nextRequest();

                case 10:
                  req = _context14.sent;
                  expect(req.url).toBe("http://tus.io/uploads");
                  expect(req.method).toBe("POST");
                  expect(req.requestHeaders["Upload-Length"]).toBe(undefined);
                  expect(req.requestHeaders["Upload-Defer-Length"]).toBe(1);
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: "http://tus.io/uploads/blargh"
                    }
                  });
                  _context14.next = 18;
                  return testStack.nextRequest();

                case 18:
                  req = _context14.sent;
                  expect(req.url).toBe("http://tus.io/uploads/blargh");
                  expect(req.method).toBe("PATCH");
                  expect(req.requestHeaders["Upload-Offset"]).toBe(0);
                  expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                  expect(req.body.length).toBe(11);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      "Upload-Offset": 11
                    }
                  });
                  _context14.next = 27;
                  return options.onProgress.toBeCalled;

                case 27:
                  expect(options.onProgress).toHaveBeenCalledWith(11, null);
                  _context14.next = 30;
                  return testStack.nextRequest();

                case 30:
                  req = _context14.sent;
                  expect(req.url).toBe("http://tus.io/uploads/blargh");
                  expect(req.method).toBe("PATCH");
                  expect(req.requestHeaders["Upload-Offset"]).toBe(11);
                  expect(req.requestHeaders["Upload-Length"]).toBe(11);
                  expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                  expect(req.body).toBe(null);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      "Upload-Offset": 11
                    }
                  });
                  _context14.next = 40;
                  return options.onSuccess.toBeCalled;

                case 40:
                  expect(upload.url).toBe("http://tus.io/uploads/blargh");
                  expect(options.onProgress).toHaveBeenCalledWith(11, 11);

                case 42:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));
        return _assertReaderUpload.apply(this, arguments);
      }

      it("should upload data", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 100
                });

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      })));
      it("should read multiple times from the reader", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 6
                });

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      })));
      it("should use multiple PATCH requests", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                reader = makeReader("hello world", 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/uploads",
                  chunkSize: 6,
                  onProgress: waitableFunction("onProgress"),
                  onSuccess: waitableFunction("onSuccess"),
                  fingerprint: function fingerprint() {},
                  uploadLengthDeferred: true
                };
                spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
                upload = new tus.Upload(reader, options);
                upload.start();
                expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                _context9.next = 9;
                return testStack.nextRequest();

              case 9:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads");
                expect(req.method).toBe("POST");
                expect(req.requestHeaders["Upload-Length"]).toBe(undefined);
                expect(req.requestHeaders["Upload-Defer-Length"]).toBe(1);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "http://tus.io/uploads/blargh"
                  }
                });
                _context9.next = 17;
                return testStack.nextRequest();

              case 17:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Offset"]).toBe(0);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body.length).toBe(6);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 6
                  }
                });
                _context9.next = 26;
                return options.onProgress.toBeCalled;

              case 26:
                expect(options.onProgress).toHaveBeenCalledWith(6, null);
                _context9.next = 29;
                return testStack.nextRequest();

              case 29:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
                expect(req.requestHeaders["Upload-Offset"]).toBe(6);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body.length).toBe(5);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context9.next = 39;
                return testStack.nextRequest();

              case 39:
                req = _context9.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Offset"]).toBe(11);
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body).toBe(null);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context9.next = 49;
                return options.onSuccess.toBeCalled;

              case 49:
                expect(upload.url).toBe("http://tus.io/uploads/blargh");
                expect(options.onProgress).toHaveBeenCalledWith(11, 11);

              case 51:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      })));
      it("should retry the POST request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                reader = makeReader("hello world", 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/files/",
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction("onSuccess"),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context10.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 500
                });
                _context10.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/files/foo"
                  }
                });
                _context10.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context10.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context10.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context10.next = 32;
                return options.onSuccess.toBeCalled;

              case 32:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      })));
      it("should retry the first PATCH request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                reader = makeReader("hello world", 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/files/",
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction("onSuccess"),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context11.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/files/foo"
                  }
                });
                _context11.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 500
                });
                _context11.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("HEAD");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 0
                  }
                });
                _context11.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context11.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context11.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context11.next = 38;
                return options.onSuccess.toBeCalled;

              case 38:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      })));
      it("should retry following PATCH requests", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
        var reader, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                reader = makeReader("hello world there!");
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/files/",
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context12.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/");
                expect(req.method).toBe("POST");
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/files/foo"
                  }
                });
                _context12.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 6
                  }
                });
                _context12.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 500
                });
                _context12.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("HEAD");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 6
                  }
                });
                _context12.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 12
                  }
                });
                _context12.next = 37;
                return testStack.nextRequest();

              case 37:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 18
                  }
                });
                _context12.next = 43;
                return testStack.nextRequest();

              case 43:
                req = _context12.sent;
                expect(req.url).toBe("http://tus.io/files/foo");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Upload-Length"]).toBe(18);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 18
                  }
                });
                _context12.next = 50;
                return options.onSuccess.toBeCalled;

              case 50:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      })));
      it("should cancel the reader when aborted", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
        var reader, options, upload;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                reader = makeReader("hello there world");
                options = {
                  httpStack: new TestHttpStack(),
                  endpoint: "http://tus.io/files/",
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start(); // We wait until the first request arrives, so that the first promises have resolved.

                _context13.next = 6;
                return options.httpStack.nextRequest();

              case 6:
                upload.abort();
                _context13.next = 9;
                return reader.cancel.toBeCalled;

              case 9:
                expect(reader.cancel).toHaveBeenCalled();

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      })));
    });
    describe("resolving of URIs", function () {
      // Disable these tests for IE 10 and 11 because it's not possible to overwrite
      // the navigator.product property.
      var isIE = navigator.userAgent.indexOf("Trident/") > 0;

      if (isIE) {
        console.log("Skipping tests for React Native in Internet Explorer"); // eslint-disable-line no-console

        return;
      }

      var originalProduct = navigator.product;
      beforeEach(function () {
        jasmine.Ajax.install(); // Simulate React Native environment to enable URIs as input objects.

        Object.defineProperty(navigator, "product", {
          value: "ReactNative",
          configurable: true
        });
      });
      afterEach(function () {
        jasmine.Ajax.uninstall();
        Object.defineProperty(navigator, "product", {
          value: originalProduct,
          configurable: true
        });
      });
      it("should upload a file from an URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
        var file, testStack, options, upload, req;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                file = {
                  uri: "file:///my/file.dat"
                };
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: "http://tus.io/uploads",
                  onSuccess: waitableFunction("onSuccess")
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context15.next = 7;
                return wait(0);

              case 7:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe("file:///my/file.dat");
                expect(req.method).toBe("GET");
                expect(req.responseType).toBe("blob");
                req.respondWith({
                  status: 200,
                  responseHeaders: {
                    "Upload-Length": 11,
                    "Upload-Offset": 3
                  },
                  response: new Blob("hello world".split(""))
                });
                _context15.next = 14;
                return testStack.nextRequest();

              case 14:
                req = _context15.sent;
                expect(req.url).toBe("http://tus.io/uploads");
                expect(req.method).toBe("POST");
                expect(req.requestHeaders["Upload-Length"]).toBe(11);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: "/uploads/blargh"
                  }
                });
                _context15.next = 21;
                return testStack.nextRequest();

              case 21:
                req = _context15.sent;
                expect(req.url).toBe("http://tus.io/uploads/blargh");
                expect(req.method).toBe("PATCH");
                expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
                expect(req.requestHeaders["Upload-Offset"]).toBe(0);
                expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
                expect(req.body.size).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    "Upload-Offset": 11
                  }
                });
                _context15.next = 31;
                return options.onSuccess.toBeCalled;

              case 31:
                expect(upload.url).toBe("http://tus.io/uploads/blargh");

              case 32:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      })));
      it("should emit an error if it can't resolve the URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
        var file, options, upload, req;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                file = {
                  uri: "file:///my/file.dat"
                };
                options = {
                  endpoint: "http://tus.io/uploads",
                  onError: waitableFunction("onError")
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context16.next = 6;
                return wait(0);

              case 6:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe("file:///my/file.dat");
                expect(req.method).toBe("GET");
                expect(req.responseType).toBe("blob");
                req.responseError();
                _context16.next = 13;
                return options.onError.toBeCalled;

              case 13:
                expect(options.onError).toHaveBeenCalledWith(new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. [object Object]"));

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      })));
    });
  });
  describe("#LocalStorageUrlStorage", function () {
    it("should allow storing and retrieving uploads", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return assertUrlStorage(tus.defaultOptions.urlStorage);

            case 2:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
  });
});

},{"../../":4,"./helpers/assertUrlStorage":53,"./helpers/utils":55}],57:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require("../../"); // Uncomment to enable debug log from tus-js-client
//tus.enableDebugLog();


describe("tus", function () {
  describe("#isSupported", function () {
    it("should be true", function () {
      expect(tus.isSupported).toBe(true);
    });
  });
  describe("#Upload", function () {
    it("should throw if no error handler is available", function () {
      var upload = new tus.Upload(null);
      expect(upload.start.bind(upload)).toThrowError("tus: no file or stream to upload provided");
    });
    it("should throw if no endpoint and upload URL is provided", function () {
      var file = getBlob("hello world");
      var upload = new tus.Upload(file);
      expect(upload.start.bind(upload)).toThrowError("tus: neither an endpoint or an upload URL is provided");
    });
    it("should upload a file", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "https://tus.io/uploads",
                headers: {
                  Custom: "blargh"
                },
                metadata: {
                  foo: "hello",
                  bar: "world",
                  nonlatin: "soce",
                  number: 100
                },
                withCredentials: true,
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11); //if (isBrowser) expect(req.withCredentials).toBe(true);

              expect(req.requestHeaders["Upload-Metadata"]).toBe("foo aGVsbG8=,bar d29ybGQ=,nonlatin c8WCb8WEY2U=,number MTAw");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/blargh"
                }
              });
              _context.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11); //if (isBrowser) expect(req.withCredentials).toBe(true);

              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context.next = 29;
              return options.onSuccess.toBeCalled;

            case 29:
              expect(upload.url).toBe("https://tus.io/uploads/blargh");
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it("should create an upload if resuming fails", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/uploads/resuming"
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 404
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11); // The upload URL should be cleared when tus-js.client tries to create a new upload.

              expect(upload.url).toBe(null);

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it("should create an upload using the creation-with-data extension", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadDataDuringCreation: true,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onProgress");
              spyOn(options, "onChunkComplete");
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh",
                  "Upload-Offset": 11
                }
              });
              _context3.next = 19;
              return options.onSuccess.toBeCalled;

            case 19:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(11, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();
              expect(upload.url).toBe("http://tus.io/uploads/blargh");

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it("should create an upload with partial data and continue", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadDataDuringCreation: true,
                chunkSize: 6,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onProgress");
              spyOn(options, "onChunkComplete");
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context4.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh",
                  "Upload-Offset": 6
                }
              });
              _context4.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context4.sent;
              // Once the second request has been sent, the progress handler must have been invoked.
              expect(options.onProgress).toHaveBeenCalledWith(6, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(6, 6, 11);
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(upload.url).toBe("http://tus.io/uploads/blargh");
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(6);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh",
                  "Upload-Offset": 11
                }
              });
              _context4.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(5, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 36:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    it("should add the request's body and ID to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var testStack, file, options, upload, req, reqId, err;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                addRequestId: true,
                retryDelays: null,
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context5.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context5.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              reqId = req.requestHeaders["X-Request-ID"];
              expect(_typeof(reqId)).toBe("string");
              expect(reqId.length).toBe(36);
              req.respondWith({
                status: 500,
                responseText: "server_error"
              });
              _context5.next = 16;
              return options.onError.toBeCalled;

            case 16:
              err = _context5.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: server_error, request id: " + reqId + ")");
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();

            case 20:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
    it("should invoke the request and response callbacks", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                uploadUrl: "http://tus.io/uploads/foo",
                onBeforeRequest: function onBeforeRequest(req) {
                  expect(req.getURL()).toBe("http://tus.io/uploads/foo");
                  expect(req.getMethod()).toBe("HEAD");
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  expect(req.getURL()).toBe("http://tus.io/uploads/foo");
                  expect(req.getMethod()).toBe("HEAD");
                  expect(res.getStatus()).toBe(204);
                  expect(res.getHeader("Upload-Offset")).toBe(11);
                },
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onBeforeRequest");
              spyOn(options, "onAfterResponse");
              upload = new tus.Upload(file, options);
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe("http://tus.io/uploads/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11,
                  "Upload-Length": 11
                }
              });
              _context6.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    it("should throw an error if resuming fails and no endpoint is provided", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                uploadUrl: "http://tus.io/uploads/resuming",
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context7.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context7.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 404
              });
              _context7.next = 14;
              return options.onError.toBeCalled;

            case 14:
              err = _context7.sent;
              expect(err.message).toBe("tus: unable to resume upload (new upload cannot be created without an endpoint), originated from request (method: HEAD, url: http://tus.io/uploads/resuming, response code: 404, response text: , request id: n/a)");

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    it("should resolve relative URLs", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io:1080/files/"
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context8.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context8.sent;
              expect(req.url).toBe("http://tus.io:1080/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "//localhost/uploads/foo"
                }
              });
              _context8.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context8.sent;
              expect(req.url).toBe("http://localhost/uploads/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              expect(upload.url).toBe("http://localhost/uploads/foo");

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    })));
    it("should upload a file in chunks", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                chunkSize: 7,
                onSuccess: waitableFunction("onSuccess"),
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {}
              };
              spyOn(options, "onProgress");
              spyOn(options, "onChunkComplete");
              upload = new tus.Upload(file, options);
              upload.start();
              _context9.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context9.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/uploads/blargh"
                }
              });
              _context9.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context9.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(7);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 7
                }
              });
              _context9.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context9.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(7);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(4);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context9.next = 37;
              return options.onSuccess.toBeCalled;

            case 37:
              expect(upload.url).toBe("http://tus.io/uploads/blargh");
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(7, 7, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(4, 11, 11);

            case 41:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    })));
    it("should add the original request to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                retryDelays: null,
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context10.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context10.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500,
                responseHeaders: {
                  Custom: "blargh"
                }
              });
              _context10.next = 13;
              return options.onError.toBeCalled;

            case 13:
              err = _context10.sent;
              expect(upload.url).toBe(null);
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: , request id: n/a)");
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();
              expect(err.originalResponse.getHeader("Custom")).toBe("blargh");

            case 19:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    })));
    it("should only create an upload for empty files", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onSuccess: waitableFunction("onSuccess")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context11.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context11.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(0);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "http://tus.io/uploads/empty"
                }
              });
              _context11.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onSuccess).toHaveBeenCalled();

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    })));
    it("should not resume a finished upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction("onSuccess"),
                uploadUrl: "http://tus.io/uploads/resuming"
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context12.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context12.sent;
              expect(req.url).toBe("http://tus.io/uploads/resuming");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": "11",
                  "Upload-Offset": "11"
                }
              });
              _context12.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    })));
    it("should resume an upload from a specified url", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/files/upload",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction("onSuccess"),
                fingerprint: function fingerprint() {}
              };
              spyOn(options, "fingerprint").and.resolveTo("fingerprinted");
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalled();
              _context13.next = 10;
              return testStack.nextRequest();

            case 10:
              req = _context13.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 3
                }
              });
              _context13.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context13.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(3);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context13.next = 27;
              return options.onSuccess.toBeCalled;

            case 27:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(upload.url).toBe("http://tus.io/files/upload");

            case 29:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    })));
    it("should resume a previously started upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onSuccess: waitableFunction("onSuccess"),
                onError: function onError() {}
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context14.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "http://tus.io/uploads/blargh"
                }
              });
              _context14.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              upload.abort();
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              upload.start();
              _context14.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5,
                  "Upload-Length": 11
                }
              });
              _context14.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context14.sent;
              expect(req.url).toBe("http://tus.io/uploads/blargh");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context14.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onSuccess).toHaveBeenCalled();

            case 34:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    })));
    it("should override the PATCH method", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/files/upload",
                overridePatchMethod: true
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context15.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context15.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("HEAD");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 3
                }
              });
              _context15.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context15.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(3);
              expect(req.requestHeaders["X-HTTP-Method-Override"]).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });

            case 21:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    })));
    it("should emit an error if an upload is locked", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                uploadUrl: "http://tus.io/files/upload",
                onError: waitableFunction("onError"),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context16.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context16.sent;
              expect(req.url).toBe("http://tus.io/files/upload");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 423 // Locked

              });
              _context16.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error("tus: upload is currently locked; retry later, originated from request (method: HEAD, url: http://tus.io/files/upload, response code: 423, response text: , request id: n/a)"));

            case 14:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    })));
    it("should emit an error if no Location header is presented", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/uploads",
                onError: waitableFunction("onError"),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context17.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context17.sent;
              expect(req.url).toBe("http://tus.io/uploads");
              expect(req.method).toBe("POST"); // The Location header is omitted on purpose here

              req.respondWith({
                status: 201
              });
              _context17.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error("tus: invalid or missing Location header, originated from request (method: POST, url: http://tus.io/uploads, response code: 201, response text: , request id: n/a)"));

            case 14:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
    it("should throw if retryDelays is not an array", function () {
      var file = getBlob("hello world");
      var upload = new tus.Upload(file, {
        endpoint: "http://endpoint/",
        retryDelays: 44
      });
      expect(upload.start.bind(upload)).toThrowError("tus: the `retryDelays` option must either be an array or null");
    }); // This tests ensures that tus-js-client correctly retries if the
    // response has the code 500 Internal Error, 423 Locked or 409 Conflict.

    it("should retry the upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction("onSuccess")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context18.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500
              });
              _context18.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context18.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 423
              });
              _context18.next = 25;
              return testStack.nextRequest();

            case 25:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context18.next = 31;
              return testStack.nextRequest();

            case 31:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 409
              });
              _context18.next = 37;
              return testStack.nextRequest();

            case 37:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context18.next = 43;
              return testStack.nextRequest();

            case 43:
              req = _context18.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context18.next = 49;
              return options.onSuccess.toBeCalled;

            case 49:
              expect(options.onSuccess).toHaveBeenCalled();

            case 50:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18);
    })));
    it("should not retry if the error has not been caused by a request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
      var file, options, upload, error;
      return regeneratorRuntime.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              file = getBlob("hello world");
              options = {
                httpStack: new TestHttpStack(),
                endpoint: "http://tus.io/files/",
                retryDelays: [10, 10, 10],
                onSuccess: function onSuccess() {},
                onError: function onError() {}
              };
              spyOn(options, "onSuccess");
              spyOn(options, "onError");
              upload = new tus.Upload(file, options);
              spyOn(upload, "_createUpload");
              upload.start();
              _context19.next = 9;
              return wait(200);

            case 9:
              error = new Error("custom error");

              upload._emitError(error);

              expect(upload._createUpload).toHaveBeenCalledTimes(1);
              expect(options.onError).toHaveBeenCalledWith(error);
              expect(options.onSuccess).not.toHaveBeenCalled();

            case 14:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    })));
    it("should stop retrying after all delays have been used", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10],
                onSuccess: function onSuccess() {},
                onError: waitableFunction("onError")
              };
              spyOn(options, "onSuccess");
              upload = new tus.Upload(file, options);
              upload.start();
              _context20.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context20.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 500
              });
              _context20.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context20.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST"); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context20.next = 21;
              return options.onError.toBeCalled;

            case 21:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 23:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20);
    })));
    it("should stop retrying when the abort function is called", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10],
                onError: function onError() {}
              };
              spyOn(options, "onError");
              upload = new tus.Upload(file, options);
              upload.start();
              _context21.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context21.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              spyOn(upload, "start").and.callThrough();
              upload.abort();
              req.respondWith({
                status: 500
              });
              _context21.next = 16;
              return Promise.race([testStack.nextRequest(), wait(100)]);

            case 16:
              result = _context21.sent;
              expect(result).toBe("timed out");

            case 18:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    })));
    it("should stop upload when the abort function is called during a callback", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  upload.abort();
                }
              };
              spyOn(options, "onChunkComplete").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context22.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context22.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context22.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context22.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context22.next = 20;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 20:
              result = _context22.sent;
              expect(options.onChunkComplete).toHaveBeenCalled();
              expect(result).toBe("timed out");

            case 23:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    })));
    it("should stop upload when the abort function is called during the POST request", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
      var testStack, file, options, upload, req, result;
      return regeneratorRuntime.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                onError: function onError() {}
              };
              spyOn(options, "onError").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context23.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context23.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              upload.abort();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context23.next = 15;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 15:
              result = _context23.sent;
              expect(options.onError).not.toHaveBeenCalled();
              expect(result).toBe("timed out");

            case 18:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    })));
    it("should reset the attempt counter if an upload proceeds", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                retryDelays: [10],
                onError: function onError() {},
                onSuccess: waitableFunction("onSuccess")
              };
              spyOn(options, "onError");
              upload = new tus.Upload(file, options);
              upload.start();
              _context24.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context24.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 500
              });
              _context24.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 0,
                  "Upload-Length": 11
                }
              });
              _context24.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context24.next = 32;
              return testStack.nextRequest();

            case 32:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 500
              });
              _context24.next = 38;
              return testStack.nextRequest();

            case 38:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5,
                  "Upload-Length": 11
                }
              });
              _context24.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context24.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 11
                }
              });
              _context24.next = 50;
              return options.onSuccess.toBeCalled;

            case 50:
              expect(options.onError).not.toHaveBeenCalled();
              expect(options.onSuccess).toHaveBeenCalled();

            case 52:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    })));
  });
});

},{"../../":4,"./helpers/utils":55}],58:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require("./helpers/utils"),
    getBlob = _require.getBlob;

var tus = require("../../");

var axios = require("axios"); // Test timeout for end-to-end tests when uploading to real server.


var END_TO_END_TIMEOUT = 20 * 1000;
describe("tus", function () {
  describe("end-to-end", function () {
    it("should upload to a real tus server", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob("hello world");
                var options = {
                  endpoint: "https://master.tus.io/files/",
                  metadata: {
                    nonlatin: "soce",
                    number: 100,
                    filename: "hello.txt",
                    filetype: "text/plain"
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/master\.tus\.io\/files\//);
                    console.log("Upload URL:", upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent).then(function (upload) {
                return upload.abort(true).then(function () {
                  return upload;
                });
              }).then(validateUploadDeletion));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), END_TO_END_TIMEOUT);
    it("should upload to a real tus server with creation-with-upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob("hello world");
                var options = {
                  endpoint: "https://master.tus.io/files/",
                  metadata: {
                    nonlatin: "soce",
                    number: 100,
                    filename: "hello.txt",
                    filetype: "text/plain"
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/master\.tus\.io\/files\//);
                    console.log("Upload URL:", upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })), END_TO_END_TIMEOUT);
  });
});

function validateUploadContent(upload) {
  return axios.get(upload.url).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe("hello world");
    return validateUploadMetadata(upload);
  });
}

function validateUploadMetadata(upload) {
  return axios.head(upload.url, {
    headers: {
      "Tus-Resumable": "1.0.0"
    }
  }).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe("");
    expect(res.headers["tus-resumable"]).toBe("1.0.0");
    expect(res.headers["upload-offset"]).toBe("11");
    expect(res.headers["upload-length"]).toBe("11"); // The values in the Upload-Metadata header may not be in the same
    // order as we submitted them (the specification does not require
    // that). Therefore, we split the values and verify that each one
    // is present.

    var metadataStr = res.headers["upload-metadata"];
    expect(metadataStr).toBeTruthy();
    var metadata = metadataStr.split(",");
    expect(metadata).toContain("filename aGVsbG8udHh0");
    expect(metadata).toContain("filetype dGV4dC9wbGFpbg==");
    expect(metadata).toContain("nonlatin c8WCb8WEY2U=");
    expect(metadata).toContain("number MTAw");
    expect(metadata.length).toBe(4);
    return upload;
  });
}

function validateUploadDeletion(upload) {
  var validateStatus = function validateStatus(status) {
    return status === 404;
  };

  return axios.get(upload.url, {
    validateStatus: validateStatus
  }).then(function (res) {
    expect(res.status).toBe(404);
    return upload;
  });
}

},{"../../":4,"./helpers/utils":55,"axios":15}],59:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require("../../");

describe("tus", function () {
  describe("parallel uploading", function () {
    it("should throw if incompatible options are used", function () {
      var file = getBlob("hello world");
      var upload = new tus.Upload(file, {
        endpoint: "https://tus.io/uploads",
        parallelUploads: 2,
        uploadUrl: "foo"
      });
      expect(upload.start.bind(upload)).toThrowError("tus: cannot use the uploadUrl option when parallelUploads is enabled");
    });
    it("should split a file into multiple parts and create an upload for each", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var testStack, testUrlStorage, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe("fingerprinted");
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(["https://tus.io/uploads/upload1", "https://tus.io/uploads/upload2"]);
                  return Promise.resolve("tus::fingerprinted::1337");
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe("tus::fingerprinted::1337");
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, "removeUpload").and.callThrough();
              spyOn(testUrlStorage, "addUpload").and.callThrough();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                parallelUploads: 2,
                retryDelays: [10],
                endpoint: "https://tus.io/uploads",
                headers: {
                  Custom: "blargh"
                },
                metadata: {
                  foo: "hello"
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve("fingerprinted");
                }
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(5);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload1"
                }
              });
              _context.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(6);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload2"
                }
              });
              _context.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(6); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 11,
                  "Upload-Offset": 0
                }
              });
              _context.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("PATCH");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 6
                }
              });
              _context.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders.Custom).toBe("blargh");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBeUndefined();
              expect(req.requestHeaders["Upload-Concat"]).toBe("final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2");
              expect(req.requestHeaders["Upload-Metadata"]).toBe("foo aGVsbG8=");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "https://tus.io/uploads/upload3"
                }
              });
              _context.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe("https://tus.io/uploads/upload3");
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it("should emit error from a partial upload", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var testStack, file, options, upload, req, err;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                retryDelays: null,
                endpoint: "https://tus.io/uploads",
                onError: waitableFunction("onError")
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(5);
              req.respondWith({
                status: 500
              });
              _context2.next = 15;
              return options.onError.toBeCalled;

            case 15:
              err = _context2.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: https://tus.io/uploads, response code: 500, response text: , request id: n/a)");
              expect(err.originalRequest).toBe(req);

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it("should resume the partial uploads", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                // The client should resume the parallel uploads, even if it is not
                // configured for new uploads.
                parallelUploads: 1,
                endpoint: "https://tus.io/uploads",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                urlStorageKey: "tus::fingerprint::1337",
                parallelUploadUrls: ["https://tus.io/uploads/upload1", "https://tus.io/uploads/upload2"]
              });
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 5,
                  "Upload-Offset": 2
                }
              });
              _context3.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 6,
                  "Upload-Offset": 0
                }
              });
              _context3.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("PATCH");
              expect(req.body.size).toBe(3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context3.next = 28;
              return testStack.nextRequest();

            case 28:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("PATCH");
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 6
                }
              });
              _context3.next = 35;
              return testStack.nextRequest();

            case 35:
              req = _context3.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Upload-Concat"]).toBe("final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "https://tus.io/uploads/upload3"
                }
              });
              _context3.next = 42;
              return options.onSuccess.toBeCalled;

            case 42:
              expect(upload.url).toBe("https://tus.io/uploads/upload3");
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 45:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it("should abort all partial uploads and resume from them", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var testStack, file, options, upload, req, req1, req2, reqPromise, result;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                endpoint: "https://tus.io/uploads",
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve("fingerprinted");
                }
              };
              spyOn(options, "onProgress");
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(5);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload1"
                }
              });
              _context4.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBe(6);
              expect(req.requestHeaders["Upload-Concat"]).toBe("partial");
              expect(req.requestHeaders["Upload-Metadata"]).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "https://tus.io/uploads/upload2"
                }
              });
              _context4.next = 28;
              return testStack.nextRequest();

            case 28:
              req1 = _context4.sent;
              expect(req1.url).toBe("https://tus.io/uploads/upload1");
              expect(req1.method).toBe("PATCH");
              expect(req1.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req1.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req1.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req1.body.size).toBe(5);
              _context4.next = 37;
              return testStack.nextRequest();

            case 37:
              req2 = _context4.sent;
              expect(req2.url).toBe("https://tus.io/uploads/upload2");
              expect(req2.method).toBe("PATCH");
              expect(req2.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req2.requestHeaders["Upload-Offset"]).toBe(0);
              expect(req2.requestHeaders["Content-Type"]).toBe("application/offset+octet-stream");
              expect(req2.body.size).toBe(6);
              upload.abort();
              req1.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              req2.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 6
                }
              }); // No further requests should be sent.

              reqPromise = testStack.nextRequest();
              _context4.next = 50;
              return Promise.race([reqPromise, wait(100)]);

            case 50:
              result = _context4.sent;
              expect(result).toBe("timed out"); // Restart the upload

              upload.start(); // Reuse the promise from before as it is not cancelled.

              _context4.next = 55;
              return reqPromise;

            case 55:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload1");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 5,
                  "Upload-Offset": 5
                }
              });
              _context4.next = 61;
              return testStack.nextRequest();

            case 61:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads/upload2");
              expect(req.method).toBe("HEAD");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Length": 6,
                  "Upload-Offset": 6
                }
              });
              _context4.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context4.sent;
              expect(req.url).toBe("https://tus.io/uploads");
              expect(req.method).toBe("POST");
              expect(req.requestHeaders["Tus-Resumable"]).toBe("1.0.0");
              expect(req.requestHeaders["Upload-Length"]).toBeUndefined();
              expect(req.requestHeaders["Upload-Concat"]).toBe("final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  "Location": "https://tus.io/uploads/upload3"
                }
              });
              _context4.next = 76;
              return options.onSuccess.toBeCalled;

            case 76:
              expect(upload.url).toBe("https://tus.io/uploads/upload3");
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 79:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../../":4,"./helpers/utils":55}],60:[function(require,module,exports){
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* global expectAsync */
var _require = require("./helpers/utils"),
    TestHttpStack = _require.TestHttpStack,
    getBlob = _require.getBlob;

var tus = require("../../");

describe("tus", function () {
  describe("terminate upload", function () {
    it("should terminate upload when abort is called with true", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var abortPromise, testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, "onChunkComplete").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 204
              });
              expect(options.onChunkComplete).toHaveBeenCalled();
              _context.next = 27;
              return abortPromise;

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it("should retry terminate when an error is returned on first try", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var abortPromise, testStack, file, options, upload, req;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob("hello world");
              options = {
                httpStack: testStack,
                endpoint: "http://tus.io/files/",
                chunkSize: 5,
                retryDelays: [10, 10, 10],
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, "onChunkComplete").and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/");
              expect(req.method).toBe("POST");
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: "/files/foo"
                }
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("PATCH");
              req.respondWith({
                status: 204,
                responseHeaders: {
                  "Upload-Offset": 5
                }
              });
              _context2.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 423
              });
              _context2.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context2.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 204
              });
              _context2.next = 32;
              return abortPromise;

            case 32:
              expect(options.onChunkComplete).toHaveBeenCalled();

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it("should stop retrying when all delays are used up", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var testStack, options, terminatePromise, req;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                retryDelays: [10, 10]
              };
              terminatePromise = tus.Upload.terminate("http://tus.io/files/foo", options);
              _context3.next = 5;
              return testStack.nextRequest();

            case 5:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 500
              });
              _context3.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 500
              });
              _context3.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context3.sent;
              expect(req.url).toBe("http://tus.io/files/foo");
              expect(req.method).toBe("DELETE");
              req.respondWith({
                status: 500
              });
              _context3.next = 23;
              return expectAsync(terminatePromise).toBeRejectedWithError(/tus: unexpected response while terminating upload/);

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
  });
});

},{"../../":4,"./helpers/utils":55}]},{},[52])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsImxpYi5lczUvYnJvd3Nlci9maW5nZXJwcmludC5qcyIsImxpYi5lczUvYnJvd3Nlci9odHRwU3RhY2suanMiLCJsaWIuZXM1L2Jyb3dzZXIvaW5kZXguanMiLCJsaWIuZXM1L2Jyb3dzZXIvaXNDb3Jkb3ZhLmpzIiwibGliLmVzNS9icm93c2VyL2lzUmVhY3ROYXRpdmUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvcmVhZEFzQnl0ZUFycmF5LmpzIiwibGliLmVzNS9icm93c2VyL3VyaVRvQmxvYi5qcyIsImxpYi5lczUvYnJvd3Nlci91cmxTdG9yYWdlLmpzIiwibGliLmVzNS9lcnJvci5qcyIsImxpYi5lczUvbG9nZ2VyLmpzIiwibGliLmVzNS9ub29wVXJsU3RvcmFnZS5qcyIsImxpYi5lczUvdXBsb2FkLmpzIiwibGliLmVzNS91dWlkLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3Mvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9hdXRvLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCJ0ZXN0L3NwZWMvYnJvd3Nlci1pbmRleC5qcyIsInRlc3Qvc3BlYy9oZWxwZXJzL2Fzc2VydFVybFN0b3JhZ2UuanMiLCJ0ZXN0L3NwZWMvaGVscGVycy9wdXBwZXRlZXIvcmVwb3J0ZXIuanMiLCJ0ZXN0L3NwZWMvaGVscGVycy91dGlscy5qcyIsInRlc3Qvc3BlYy90ZXN0LWJyb3dzZXItc3BlY2lmaWMuanMiLCJ0ZXN0L3NwZWMvdGVzdC1jb21tb24uanMiLCJ0ZXN0L3NwZWMvdGVzdC1lbmQtdG8tZW5kLmpzIiwidGVzdC9zcGVjL3Rlc3QtcGFyYWxsZWwtdXBsb2Fkcy5qcyIsInRlc3Qvc3BlYy90ZXN0LXRlcm1pbmF0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQUVBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQzNDLEVBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0EsT0FBTyxXQUFQLEdBQWtCLEtBQUssQ0FBdkI7O0FBRUEsSUFBSSxjQUFjLEdBQUcsc0JBQXNCLENBQUMsT0FBTyxD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN0cENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdGFBOztBQUVBOztBQUxBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLENBQVQsR0FBYTtBQUNYLEVBQUEsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBckI7QUFDRDs7QUFDRCxDQUFDO0FBRUQsVUFBVSxDQUFDLFlBQVk7QUFDckI7QUFDQTtBQUNBLEVBQUEsWUFBWSxDQUFDLEtBQWI7QUFDRCxDQUpTLENBQVY7O0FBTUEsT0FBTyxDQUFDLGlDQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLGtCQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLDRCQUFELENBQVA7O0FBQ0EsT0FBTyxDQUFDLDRCQUFELENBQVA7O0FBQ0Es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O0FBQUE7QUFBQSxLQUFyRCxHQUFGO0FBbUNELEdBckpPLENBQVI7QUFzSkQsQ0F2Sk8sQ0FBUiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpKTtcblxudmFyIF91cmlUb0Jsb2IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3VyaVRvQmxvYlwiKSk7XG5cbnZhciBfaXNDb3Jkb3ZhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0NvcmRvdmFcIikpO1xuXG52YXIgX3JlYWRBc0J5dGVBcnJheSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVhZEFzQnl0ZUFycmF5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE1ha2UgdGhpcy5zaXplIGEgbWV0aG9kXG4gIGZ1bmN0aW9uIEZpbGVTb3VyY2UoZmlsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlU291cmNlKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICAgIHRoaXMuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAvLyBJbiBBcGFjaGUgQ29yZG92YSBhcHBsaWNhdGlvbnMsIGEgRmlsZSBtdXN0IGJlIHJlc29sdmVkIHVzaW5nXG4gICAgICAvLyBGaWxlUmVhZGVyIGluc3RhbmNlcywgc2VlXG4gICAgICAvLyBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuLzgueC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gICAgICBpZiAoKDAsIF9pc0NvcmRvdmEuZGVmYXVsdCkoKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9yZWFkQXNCeXRlQXJyYXkuZGVmYXVsdCkodGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHsvLyBOb3RoaW5nIHRvIGRvIGhlcmUgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMuXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVTb3VyY2U7XG59KCk7XG5cbnZhciBTdHJlYW1Tb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJlYW1Tb3VyY2UocmVhZGVyLCBjaHVua1NpemUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyZWFtU291cmNlKTtcblxuICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICB0aGlzLl9idWZmZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9yZWFkZXIgPSByZWFkZXI7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmVhbVNvdXJjZSwgW3tcbiAgICBrZXk6IFwic2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKHN0YXJ0IDwgdGhpcy5fYnVmZmVyT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgZGF0YSBpcyBiZWZvcmUgdGhlIHJlYWRlcidzIGN1cnJlbnQgb2Zmc2V0XCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBoYXNFbm91Z2hEYXRhID0gZW5kIDw9IHRoaXMuX2J1ZmZlck9mZnNldCArIGxlbih0aGlzLl9idWZmZXIpO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSB8fCBoYXNFbm91Z2hEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIHZhciBkb25lID0gdmFsdWUgPT0gbnVsbCA/IHRoaXMuX2RvbmUgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmLmRvbmU7XG5cbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBfdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMuX2J1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSBjb25jYXQoX3RoaXMuX2J1ZmZlciwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREYXRhRnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gUmVtb3ZlIGRhdGEgZnJvbSBidWZmZXIgYmVmb3JlIGBzdGFydGAuXG4gICAgICAvLyBEYXRhIG1pZ2h0IGJlIHJlcmVhZCBmcm9tIHRoZSBidWZmZXIgaWYgYW4gdXBsb2FkIGZhaWxzLCBzbyB3ZSBjYW4gb25seVxuICAgICAgLy8gc2FmZWx5IGRlbGV0ZSBkYXRhIHdoZW4gaXQgY29tZXMgKmJlZm9yZSogd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC5cbiAgICAgIGlmIChzdGFydCA+IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQgLSB0aGlzLl9idWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSBzdGFydDtcbiAgICAgIH0gLy8gSWYgdGhlIGJ1ZmZlciBpcyBlbXB0eSBhZnRlciByZW1vdmluZyBvbGQgZGF0YSwgYWxsIGRhdGEgaGFzIGJlZW4gcmVhZC5cblxuXG4gICAgICB2YXIgaGFzQWxsRGF0YUJlZW5SZWFkID0gbGVuKHRoaXMuX2J1ZmZlcikgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLl9kb25lICYmIGhhc0FsbERhdGFCZWVuUmVhZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gV2UgYWxyZWFkeSByZW1vdmVkIGRhdGEgYmVmb3JlIGBzdGFydGAsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmaXJzdFxuICAgICAgLy8gY2h1bmsgZnJvbSB0aGUgYnVmZmVyLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXIuc2xpY2UoMCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIuY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RyZWFtU291cmNlO1xufSgpO1xuXG5mdW5jdGlvbiBsZW4oYmxvYk9yQXJyYXkpIHtcbiAgaWYgKGJsb2JPckFycmF5ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICBpZiAoYmxvYk9yQXJyYXkuc2l6ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmxvYk9yQXJyYXkuc2l6ZTtcbiAgcmV0dXJuIGJsb2JPckFycmF5Lmxlbmd0aDtcbn1cbi8qXG4gIFR5cGVkIGFycmF5cyBhbmQgYmxvYnMgZG9uJ3QgaGF2ZSBhIGNvbmNhdCBtZXRob2QuXG4gIFRoaXMgZnVuY3Rpb24gaGVscHMgU3RyZWFtU291cmNlIGFjY3VtdWxhdGUgZGF0YSB0byByZWFjaCBjaHVua1NpemUuXG4qL1xuXG5cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChhLmNvbmNhdCkge1xuICAgIC8vIElzIGBhYCBhbiBBcnJheT9cbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2EsIGJdLCB7XG4gICAgICB0eXBlOiBhLnR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhLnNldCkge1xuICAgIC8vIElzIGBhYCBhIHR5cGVkIGFycmF5P1xuICAgIHZhciBjID0gbmV3IGEuY29uc3RydWN0b3IoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgYy5zZXQoYSk7XG4gICAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGVcIik7XG59XG5cbnZhciBGaWxlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsZVJlYWRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZVJlYWRlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsZVJlYWRlciwgW3tcbiAgICBrZXk6IFwib3BlbkZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbkZpbGUoaW5wdXQsIGNodW5rU2l6ZSkge1xuICAgICAgLy8gSW4gUmVhY3QgTmF0aXZlLCB3aGVuIHVzZXIgc2VsZWN0cyBhIGZpbGUsIGluc3RlYWQgb2YgYSBGaWxlIG9yIEJsb2IsXG4gICAgICAvLyB5b3UgdXN1YWxseSBnZXQgYSBmaWxlIG9iamVjdCB7fSB3aXRoIGEgdXJpIHByb3BlcnR5IHRoYXQgY29udGFpbnNcbiAgICAgIC8vIGEgbG9jYWwgcGF0aCB0byB0aGUgZmlsZS4gV2UgdXNlIFhNTEh0dHBSZXF1ZXN0IHRvIGZldGNoXG4gICAgICAvLyB0aGUgZmlsZSBibG9iLCBiZWZvcmUgdXBsb2FkaW5nIHdpdGggdHVzLlxuICAgICAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZS5kZWZhdWx0KSgpICYmIGlucHV0ICYmIHR5cGVvZiBpbnB1dC51cmkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfdXJpVG9CbG9iLmRlZmF1bHQpKGlucHV0LnVyaSkudGhlbihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgIHJldHVybiBuZXcgRmlsZVNvdXJjZShibG9iKTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHVzOiBjYW5ub3QgZmV0Y2ggYGZpbGUudXJpYCBhcyBCbG9iLCBtYWtlIHN1cmUgdGhlIHVyaSBpcyBjb3JyZWN0IGFuZCBhY2Nlc3NpYmxlLiBcIiArIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTaW5jZSB3ZSBlbXVsYXRlIHRoZSBCbG9iIHR5cGUgaW4gb3VyIHRlc3RzIChub3QgYWxsIHRhcmdldCBicm93c2Vyc1xuICAgICAgLy8gc3VwcG9ydCBpdCksIHdlIGNhbm5vdCB1c2UgYGluc3RhbmNlb2ZgIGZvciB0ZXN0aW5nIHdoZXRoZXIgdGhlIGlucHV0IHZhbHVlXG4gICAgICAvLyBjYW4gYmUgaGFuZGxlZC4gSW5zdGVhZCwgd2Ugc2ltcGx5IGNoZWNrIGlzIHRoZSBzbGljZSgpIGZ1bmN0aW9uIGFuZCB0aGVcbiAgICAgIC8vIHNpemUgcHJvcGVydHkgYXJlIGF2YWlsYWJsZS5cblxuXG4gICAgICBpZiAodHlwZW9mIGlucHV0LnNsaWNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRmlsZVNvdXJjZShpbnB1dCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGlucHV0LnJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjaHVua1NpemUgPSArY2h1bmtTaXplO1xuXG4gICAgICAgIGlmICghaXNGaW5pdGUoY2h1bmtTaXplKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3QgY3JlYXRlIHNvdXJjZSBmb3Igc3RyZWFtIHdpdGhvdXQgYSBmaW5pdGUgdmFsdWUgZm9yIHRoZSBgY2h1bmtTaXplYCBvcHRpb25cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgU3RyZWFtU291cmNlKGlucHV0LCBjaHVua1NpemUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNvdXJjZSBvYmplY3QgbWF5IG9ubHkgYmUgYW4gaW5zdGFuY2Ugb2YgRmlsZSwgQmxvYiwgb3IgUmVhZGVyIGluIHRoaXMgZW52aXJvbm1lbnRcIikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxlUmVhZGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxlUmVhZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmluZ2VycHJpbnQ7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIFRPRE86IERpZmZlcmVuY2lhdGUgYmV0d2VlbiBpbnB1dCB0eXBlc1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmluZ2VycHJpbnQgZm9yIGEgZmlsZSB3aGljaCB3aWxsIGJlIHVzZWQgdGhlIHN0b3JlIHRoZSBlbmRwb2ludFxuICpcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpIHtcbiAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZS5kZWZhdWx0KSgpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFjdE5hdGl2ZUZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1widHVzLWJyXCIsIGZpbGUubmFtZSwgZmlsZS50eXBlLCBmaWxlLnNpemUsIGZpbGUubGFzdE1vZGlmaWVkLCBvcHRpb25zLmVuZHBvaW50XS5qb2luKFwiLVwiKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWN0TmF0aXZlRmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucykge1xuICB2YXIgZXhpZkhhc2ggPSBmaWxlLmV4aWYgPyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShmaWxlLmV4aWYpKSA6IFwibm9leGlmXCI7XG4gIHJldHVybiBbXCJ0dXMtcm5cIiwgZmlsZS5uYW1lIHx8IFwibm9uYW1lXCIsIGZpbGUuc2l6ZSB8fCBcIm5vc2l6ZVwiLCBleGlmSGFzaCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbihcIi9cIik7XG59XG5cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICAvLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84ODMxOTM3LzE1MTY2NlxuICB2YXIgaGFzaCA9IDA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgX2NoYXI7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIFhIUkh0dHBTdGFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhIUkh0dHBTdGFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWEhSSHR0cFN0YWNrKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYSFJIdHRwU3RhY2ssIFt7XG4gICAga2V5OiBcImNyZWF0ZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lKCkge1xuICAgICAgcmV0dXJuIFwiWEhSSHR0cFN0YWNrXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFhIUkh0dHBTdGFjaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gWEhSSHR0cFN0YWNrO1xuXG52YXIgUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVxdWVzdCk7XG5cbiAgICB0aGlzLl94aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIHRoaXMuX3hoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlcXVlc3QsIFt7XG4gICAga2V5OiBcImdldE1ldGhvZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRob2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VVJMKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlYWRlcihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICB0aGlzLl94aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIHZhbHVlKTtcblxuICAgICAgdGhpcy5faGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9ncmVzc0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvZ3Jlc3NIYW5kbGVyKHByb2dyZXNzSGFuZGxlcikge1xuICAgICAgLy8gVGVzdCBzdXBwb3J0IGZvciBwcm9ncmVzcyBldmVudHMgYmVmb3JlIGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKCEoXCJ1cGxvYWRcIiBpbiB0aGlzLl94aHIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5feGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmVzc0hhbmRsZXIoZS5sb2FkZWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGJvZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpcy5feGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShfdGhpcy5feGhyKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX3hoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLl94aHIuc2VuZChib2R5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVuZGVybHlpbmdPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VW5kZXJseWluZ09iamVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlcXVlc3Q7XG59KCk7XG5cbnZhciBSZXNwb25zZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3BvbnNlKHhocikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zZSk7XG5cbiAgICB0aGlzLl94aHIgPSB4aHI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2UsIFt7XG4gICAga2V5OiBcImdldFN0YXR1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0dXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLnN0YXR1cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlcihoZWFkZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuZ2V0UmVzcG9uc2VIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9keVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVuZGVybHlpbmdPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VW5kZXJseWluZ09iamVjdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc3BvbnNlO1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5hYmxlRGVidWdMb2dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2xvZ2dlci5lbmFibGVEZWJ1Z0xvZztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5TdG9yZVVSTHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzO1xuICB9XG59KTtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5VcGxvYWQgPSB2b2lkIDA7XG5cbnZhciBfdXBsb2FkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXBsb2FkXCIpKTtcblxudmFyIF9ub29wVXJsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vb3BVcmxTdG9yYWdlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuXG52YXIgX3VybFN0b3JhZ2UgPSByZXF1aXJlKFwiLi91cmxTdG9yYWdlXCIpO1xuXG52YXIgX2h0dHBTdGFjayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaHR0cFN0YWNrXCIpKTtcblxudmFyIF9maWxlUmVhZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9maWxlUmVhZGVyXCIpKTtcblxudmFyIF9maW5nZXJwcmludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmluZ2VycHJpbnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG4vKiBnbG9iYWwgd2luZG93ICovXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgX3VwbG9hZC5kZWZhdWx0LmRlZmF1bHRPcHRpb25zLCB7XG4gIGh0dHBTdGFjazogbmV3IF9odHRwU3RhY2suZGVmYXVsdCgpLFxuICBmaWxlUmVhZGVyOiBuZXcgX2ZpbGVSZWFkZXIuZGVmYXVsdCgpLFxuICB1cmxTdG9yYWdlOiBfdXJsU3RvcmFnZS5jYW5TdG9yZVVSTHMgPyBuZXcgX3VybFN0b3JhZ2UuV2ViU3RvcmFnZVVybFN0b3JhZ2UoKSA6IG5ldyBfbm9vcFVybFN0b3JhZ2UuZGVmYXVsdCgpLFxuICBmaW5nZXJwcmludDogX2ZpbmdlcnByaW50LmRlZmF1bHRcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5cbnZhciBVcGxvYWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlVXBsb2FkKSB7XG4gIF9pbmhlcml0cyhVcGxvYWQsIF9CYXNlVXBsb2FkKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFVwbG9hZCk7XG5cbiAgZnVuY3Rpb24gVXBsb2FkKCkge1xuICAgIHZhciBmaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGxvYWQpO1xuXG4gICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLCB7fSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZpbGUsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFVwbG9hZCwgbnVsbCwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMsIHt9LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBfdXBsb2FkLmRlZmF1bHQudGVybWluYXRlKHVybCwgb3B0aW9ucywgY2IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVcGxvYWQ7XG59KF91cGxvYWQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVXBsb2FkID0gVXBsb2FkO1xudmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgWE1MSHR0cFJlcXVlc3QgPSBfd2luZG93LlhNTEh0dHBSZXF1ZXN0LFxuICAgIEJsb2IgPSBfd2luZG93LkJsb2I7XG52YXIgaXNTdXBwb3J0ZWQgPSBYTUxIdHRwUmVxdWVzdCAmJiBCbG9iICYmIHR5cGVvZiBCbG9iLnByb3RvdHlwZS5zbGljZSA9PT0gXCJmdW5jdGlvblwiO1xuZXhwb3J0cy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNDb3Jkb3ZhID0gZnVuY3Rpb24gaXNDb3Jkb3ZhKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2Ygd2luZG93LlBob25lR2FwICE9IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5Db3Jkb3ZhICE9IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5jb3Jkb3ZhICE9IFwidW5kZWZpbmVkXCIpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gaXNDb3Jkb3ZhO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBpc1JlYWN0TmF0aXZlID0gZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcInN0cmluZ1wiICYmIG5hdmlnYXRvci5wcm9kdWN0LnRvTG93ZXJDYXNlKCkgPT09IFwicmVhY3RuYXRpdmVcIjtcbn07XG5cbnZhciBfZGVmYXVsdCA9IGlzUmVhY3ROYXRpdmU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlYWRBc0J5dGVBcnJheTtcblxuLyoqXG4gKiByZWFkQXNCeXRlQXJyYXkgY29udmVydHMgYSBGaWxlIG9iamVjdCB0byBhIFVpbnQ4QXJyYXkuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBvbiB0aGUgQXBhY2hlIENvcmRvdmEgcGxhdGZvcm0uXG4gKiBTZWUgaHR0cHM6Ly9jb3Jkb3ZhLmFwYWNoZS5vcmcvZG9jcy9lbi9sYXRlc3QvcmVmZXJlbmNlL2NvcmRvdmEtcGx1Z2luLWZpbGUvaW5kZXguaHRtbCNyZWFkLWEtZmlsZVxuICovXG5mdW5jdGlvbiByZWFkQXNCeXRlQXJyYXkoY2h1bmspIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2h1bmspO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaVRvQmxvYjtcblxuLyoqXG4gKiB1cmlUb0Jsb2IgcmVzb2x2ZXMgYSBVUkkgdG8gYSBCbG9iIG9iamVjdC4gVGhpcyBpcyB1c2VkIGZvclxuICogUmVhY3QgTmF0aXZlIHRvIHJldHJpZXZlIGEgZmlsZSAoaWRlbnRpZmllZCBieSBhIGZpbGU6Ly9cbiAqIFVSSSkgYXMgYSBibG9iLlxuICovXG5mdW5jdGlvbiB1cmlUb0Jsb2IodXJpKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImJsb2JcIjtcblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYmxvYiA9IHhoci5yZXNwb25zZTtcbiAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgfTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcblxuICAgIHhoci5vcGVuKFwiR0VUXCIsIHVyaSk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLldlYlN0b3JhZ2VVcmxTdG9yYWdlID0gZXhwb3J0cy5jYW5TdG9yZVVSTHMgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3csIGxvY2FsU3RvcmFnZSAqL1xuXG5cbnZhciBoYXNTdG9yYWdlID0gZmFsc2U7XG5cbnRyeSB7XG4gIGhhc1N0b3JhZ2UgPSBcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdzsgLy8gQXR0ZW1wdCB0byBzdG9yZSBhbmQgcmVhZCBlbnRyaWVzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2UgdG8gZGV0ZWN0IFByaXZhdGVcbiAgLy8gTW9kZSBvbiBTYWZhcmkgb24gaU9TIChzZWUgIzQ5KVxuXG4gIHZhciBrZXkgPSBcInR1c1N1cHBvcnRcIjtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSWYgd2UgdHJ5IHRvIGFjY2VzcyBsb2NhbFN0b3JhZ2UgaW5zaWRlIGEgc2FuZGJveGVkIGlmcmFtZSwgYSBTZWN1cml0eUVycm9yXG4gIC8vIGlzIHRocm93bi4gV2hlbiBpbiBwcml2YXRlIG1vZGUgb24gaU9TIFNhZmFyaSwgYSBRdW90YUV4Y2VlZGVkRXJyb3IgaXNcbiAgLy8gdGhyb3duIChzZWUgIzQ5KVxuICBpZiAoZS5jb2RlID09PSBlLlNFQ1VSSVRZX0VSUiB8fCBlLmNvZGUgPT09IGUuUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgaGFzU3RvcmFnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxudmFyIGNhblN0b3JlVVJMcyA9IGhhc1N0b3JhZ2U7XG5leHBvcnRzLmNhblN0b3JlVVJMcyA9IGNhblN0b3JlVVJMcztcblxudmFyIFdlYlN0b3JhZ2VVcmxTdG9yYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViU3RvcmFnZVVybFN0b3JhZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlN0b3JhZ2VVcmxTdG9yYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJTdG9yYWdlVXJsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwiZmluZEFsbFVwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFsbFVwbG9hZHMoKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2ZpbmRFbnRyaWVzKFwidHVzOjpcIik7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGxvYWQodXJsU3RvcmFnZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odXJsU3RvcmFnZUtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgdmFyIGlkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxMik7XG4gICAgICB2YXIga2V5ID0gXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKS5jb25jYXQoaWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh1cGxvYWQpKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRFbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRW50cmllcyhwcmVmaXgpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfa2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICBpZiAoX2tleS5pbmRleE9mKHByZWZpeCkgIT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oX2tleSkpO1xuICAgICAgICAgIHVwbG9hZC51cmxTdG9yYWdlS2V5ID0gX2tleTtcbiAgICAgICAgICByZXN1bHRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIFRoZSBKU09OIHBhcnNlIGVycm9yIGlzIGludGVudGlvbmFsbHkgaWdub3JlZCBoZXJlLCBzbyBhIG1hbGZvcm1lZFxuICAgICAgICAgIC8vIGVudHJ5IGluIHRoZSBzdG9yYWdlIGNhbm5vdCBwcmV2ZW50IGFuIHVwbG9hZC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViU3RvcmFnZVVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSBXZWJTdG9yYWdlVXJsU3RvcmFnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbnZhciBEZXRhaWxlZEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKERldGFpbGVkRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEZXRhaWxlZEVycm9yKTtcblxuICBmdW5jdGlvbiBEZXRhaWxlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgY2F1c2luZ0VyciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICB2YXIgcmVxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGV0YWlsZWRFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLm9yaWdpbmFsUmVxdWVzdCA9IHJlcTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlc3BvbnNlID0gcmVzO1xuICAgIF90aGlzLmNhdXNpbmdFcnJvciA9IGNhdXNpbmdFcnI7XG5cbiAgICBpZiAoY2F1c2luZ0VyciAhPSBudWxsKSB7XG4gICAgICBtZXNzYWdlICs9IFwiLCBjYXVzZWQgYnkgXCIuY29uY2F0KGNhdXNpbmdFcnIudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVxdWVzdElkID0gcmVxLmdldEhlYWRlcihcIlgtUmVxdWVzdC1JRFwiKSB8fCBcIm4vYVwiO1xuICAgICAgdmFyIG1ldGhvZCA9IHJlcS5nZXRNZXRob2QoKTtcbiAgICAgIHZhciB1cmwgPSByZXEuZ2V0VVJMKCk7XG4gICAgICB2YXIgc3RhdHVzID0gcmVzID8gcmVzLmdldFN0YXR1cygpIDogXCJuL2FcIjtcbiAgICAgIHZhciBib2R5ID0gcmVzID8gcmVzLmdldEJvZHkoKSB8fCBcIlwiIDogXCJuL2FcIjtcbiAgICAgIG1lc3NhZ2UgKz0gXCIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFwiLmNvbmNhdChtZXRob2QsIFwiLCB1cmw6IFwiKS5jb25jYXQodXJsLCBcIiwgcmVzcG9uc2UgY29kZTogXCIpLmNvbmNhdChzdGF0dXMsIFwiLCByZXNwb25zZSB0ZXh0OiBcIikuY29uY2F0KGJvZHksIFwiLCByZXF1ZXN0IGlkOiBcIikuY29uY2F0KHJlcXVlc3RJZCwgXCIpXCIpO1xuICAgIH1cblxuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBEZXRhaWxlZEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIF9kZWZhdWx0ID0gRGV0YWlsZWRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5lbmFibGVEZWJ1Z0xvZyA9IGVuYWJsZURlYnVnTG9nO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5cbi8qIGVzbGludCBuby1jb25zb2xlOiBcIm9mZlwiICovXG52YXIgaXNFbmFibGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVuYWJsZURlYnVnTG9nKCkge1xuICBpc0VuYWJsZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2cobXNnKSB7XG4gIGlmICghaXNFbmFibGVkKSByZXR1cm47XG4gIGNvbnNvbGUubG9nKG1zZyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuXG5cbnZhciBOb29wVXJsU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vb3BVcmxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb29wVXJsU3RvcmFnZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTm9vcFVybFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImxpc3RBbGxVcGxvYWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RBbGxVcGxvYWRzKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBsb2FkKHVybFN0b3JhZ2VLZXkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFVwbG9hZChmaW5nZXJwcmludCwgdXBsb2FkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb29wVXJsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTm9vcFVybFN0b3JhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfZXJyb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Vycm9yXCIpKTtcblxudmFyIF91dWlkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dWlkXCIpKTtcblxudmFyIF9qc0Jhc2UgPSByZXF1aXJlKFwianMtYmFzZTY0XCIpO1xuXG52YXIgX3VybFBhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidXJsLXBhcnNlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuZHBvaW50OiBudWxsLFxuICB1cGxvYWRVcmw6IG51bGwsXG4gIG1ldGFkYXRhOiB7fSxcbiAgZmluZ2VycHJpbnQ6IG51bGwsXG4gIHVwbG9hZFNpemU6IG51bGwsXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IG51bGwsXG4gIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IGZhbHNlLFxuICBoZWFkZXJzOiB7fSxcbiAgYWRkUmVxdWVzdElkOiBmYWxzZSxcbiAgb25CZWZvcmVSZXF1ZXN0OiBudWxsLFxuICBvbkFmdGVyUmVzcG9uc2U6IG51bGwsXG4gIGNodW5rU2l6ZTogSW5maW5pdHksXG4gIHJldHJ5RGVsYXlzOiBbMCwgMTAwMCwgMzAwMCwgNTAwMF0sXG4gIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiB0cnVlLFxuICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gIHVwbG9hZExlbmd0aERlZmVycmVkOiBmYWxzZSxcbiAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiBmYWxzZSxcbiAgdXJsU3RvcmFnZTogbnVsbCxcbiAgZmlsZVJlYWRlcjogbnVsbCxcbiAgaHR0cFN0YWNrOiBudWxsXG59O1xuXG52YXIgQmFzZVVwbG9hZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VVcGxvYWQoZmlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVXBsb2FkKTsgLy8gV2FybiBhYm91dCByZW1vdmVkIG9wdGlvbnMgZnJvbSBwcmV2aW91cyB2ZXJzaW9uc1xuXG5cbiAgICBpZiAoXCJyZXN1bWVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInR1czogVGhlIGByZXN1bWVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkIGluIHR1cy1qcy1jbGllbnQgdjIuIFBsZWFzZSB1c2UgdGhlIFVSTCBzdG9yYWdlIEFQSSBpbnN0ZWFkLlwiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfSAvLyBUaGUgZGVmYXVsdCBvcHRpb25zIHdpbGwgYWxyZWFkeSBiZSBhZGRlZCBmcm9tIHRoZSB3cmFwcGVyIGNsYXNzZXMuXG5cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIFRoZSBzdG9yYWdlIG1vZHVsZSB1c2VkIHRvIHN0b3JlIFVSTHNcblxuICAgIHRoaXMuX3VybFN0b3JhZ2UgPSB0aGlzLm9wdGlvbnMudXJsU3RvcmFnZTsgLy8gVGhlIHVuZGVybHlpbmcgRmlsZS9CbG9iIG9iamVjdFxuXG4gICAgdGhpcy5maWxlID0gZmlsZTsgLy8gVGhlIFVSTCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWRcblxuICAgIHRoaXMudXJsID0gbnVsbDsgLy8gVGhlIHVuZGVybHlpbmcgcmVxdWVzdCBvYmplY3QgZm9yIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcblxuICAgIHRoaXMuX3JlcSA9IG51bGw7IC8vIFRoZSBmaW5nZXJwaW5ydCBmb3IgdGhlIGN1cnJlbnQgZmlsZSAoc2V0IGFmdGVyIHN0YXJ0KCkpXG5cbiAgICB0aGlzLl9maW5nZXJwcmludCA9IG51bGw7IC8vIFRoZSBrZXkgdGhhdCB0aGUgVVJMIHN0b3JhZ2UgcmV0dXJuZWQgd2hlbiBzYXZpbmcgYW4gVVJMIHdpdGggYSBmaW5nZXJwcmludCxcblxuICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsOyAvLyBUaGUgb2Zmc2V0IHVzZWQgaW4gdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdFxuXG4gICAgdGhpcy5fb2Zmc2V0ID0gbnVsbDsgLy8gVHJ1ZSBpZiB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWRcblxuICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTsgLy8gVGhlIGZpbGUncyBzaXplIGluIGJ5dGVzXG5cbiAgICB0aGlzLl9zaXplID0gbnVsbDsgLy8gVGhlIFNvdXJjZSBvYmplY3Qgd2hpY2ggd2lsbCB3cmFwIGFyb3VuZCB0aGUgZ2l2ZW4gZmlsZSBhbmQgcHJvdmlkZXMgdXNcbiAgICAvLyB3aXRoIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGdldHRpbmcgaXRzIHNpemUgYW5kIHNsaWNlIGNodW5rcyBmcm9tIGl0c1xuICAgIC8vIGNvbnRlbnQgYWxsb3dpbmcgdXMgdG8gZWFzaWx5IGhhbmRsZSBGaWxlcywgQmxvYnMsIEJ1ZmZlcnMgYW5kIFN0cmVhbXMuXG5cbiAgICB0aGlzLl9zb3VyY2UgPSBudWxsOyAvLyBUaGUgY3VycmVudCBjb3VudCBvZiBhdHRlbXB0cyB3aGljaCBoYXZlIGJlZW4gbWFkZS4gWmVybyBpbmRpY2F0ZXMgbm9uZS5cblxuICAgIHRoaXMuX3JldHJ5QXR0ZW1wdCA9IDA7IC8vIFRoZSB0aW1lb3V0J3MgSUQgd2hpY2ggaXMgdXNlZCB0byBkZWxheSB0aGUgbmV4dCByZXRyeVxuXG4gICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gbnVsbDsgLy8gVGhlIG9mZnNldCBvZiB0aGUgcmVtb3RlIHVwbG9hZCBiZWZvcmUgdGhlIGxhdGVzdCBhdHRlbXB0IHdhcyBzdGFydGVkLlxuXG4gICAgdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnkgPSAwOyAvLyBBbiBhcnJheSBvZiBCYXNlVXBsb2FkIGluc3RhbmNlcyB3aGljaCBhcmUgdXNlZCBmb3IgdXBsb2FkaW5nIHRoZSBkaWZmZXJlbnRcbiAgICAvLyBwYXJ0cywgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZC5cblxuICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkcyA9IG51bGw7IC8vIEFuIGFycmF5IG9mIHVwbG9hZCBVUkxzIHdoaWNoIGFyZSB1c2VkIGZvciB1cGxvYWRpbmcgdGhlIGRpZmZlcmVudFxuICAgIC8vIHBhcnRzLCBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkLlxuXG4gICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVXNlIHRoZSBUZXJtaW5hdGlvbiBleHRlbnNpb24gdG8gZGVsZXRlIGFuIHVwbG9hZCBmcm9tIHRoZSBzZXJ2ZXIgYnkgc2VuZGluZyBhIERFTEVURVxuICAgKiByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgdXBsb2FkIFVSTC4gVGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgdGhlXG4gICAqIFRlcm1pbmF0aW9uIGV4dGVuc2lvbi4gSWYgdGhlIGBvcHRpb25zLnJldHJ5RGVsYXlzYCBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBtZXRob2Qgd2lsbFxuICAgKiBhbHNvIHJldHJ5IGlmIGFuIGVycm9yIG9jdXJycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXBsb2FkJ3MgVVJMIHdoaWNoIHdpbGwgYmUgdGVybWluYXRlZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBmb3IgaW5mbHVlbmNpbmcgSFRUUCByZXF1ZXN0cy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZC9yZWplY3RlZCB3aGVuIHRoZSByZXF1ZXN0cyBmaW5pc2guXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VVcGxvYWQsIFt7XG4gICAga2V5OiBcImZpbmRQcmV2aW91c1VwbG9hZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFByZXZpb3VzVXBsb2FkcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmluZ2VycHJpbnQodGhpcy5maWxlLCB0aGlzLm9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc3VtZUZyb21QcmV2aW91c1VwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQocHJldmlvdXNVcGxvYWQpIHtcbiAgICAgIHRoaXMudXJsID0gcHJldmlvdXNVcGxvYWQudXBsb2FkVXJsIHx8IG51bGw7XG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBwcmV2aW91c1VwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMgfHwgbnVsbDtcbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBwcmV2aW91c1VwbG9hZC51cmxTdG9yYWdlS2V5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZTtcblxuICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IG5vIGZpbGUgb3Igc3RyZWFtIHRvIHVwbG9hZCBwcm92aWRlZFwiKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZFVybCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBuZWl0aGVyIGFuIGVuZHBvaW50IG9yIGFuIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWRcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHJ5RGVsYXlzID0gdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlzO1xuXG4gICAgICBpZiAocmV0cnlEZWxheXMgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmV0cnlEZWxheXMpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogdGhlIGByZXRyeURlbGF5c2Agb3B0aW9uIG11c3QgZWl0aGVyIGJlIGFuIGFycmF5IG9yIG51bGxcIikpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxKSB7XG4gICAgICAgIC8vIFRlc3Qgd2hpY2ggb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlIHdpdGggcGFyYWxsZWwgdXBsb2Fkcy5cbiAgICAgICAgW1widXBsb2FkVXJsXCIsIFwidXBsb2FkU2l6ZVwiLCBcInVwbG9hZExlbmd0aERlZmVycmVkXCJdLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIF90aGlzMi5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IHVzZSB0aGUgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiIG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBlbmFibGVkXCIpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgaWYgKGZpbmdlcnByaW50ID09IG51bGwpIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiTm8gZmluZ2VycHJpbnQgd2FzIGNhbGN1bGF0ZWQgbWVhbmluZyB0aGF0IHRoZSB1cGxvYWQgY2Fubm90IGJlIHN0b3JlZCBpbiB0aGUgVVJMIHN0b3JhZ2UuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDYWxjdWxhdGVkIGZpbmdlcnByaW50OiBcIi5jb25jYXQoZmluZ2VycHJpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcblxuICAgICAgICBpZiAoX3RoaXMyLl9zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zb3VyY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5vcHRpb25zLmZpbGVSZWFkZXIub3BlbkZpbGUoZmlsZSwgX3RoaXMyLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIF90aGlzMi5fc291cmNlID0gc291cmNlOyAvLyBJZiB0aGUgdXBsb2FkIHdhcyBjb25maWd1cmVkIHRvIHVzZSBtdWx0aXBsZSByZXF1ZXN0cyBvciBpZiB3ZSByZXN1bWUgZnJvbVxuICAgICAgICAvLyBhbiB1cGxvYWQgd2hpY2ggdXNlZCBtdWx0aXBsZSByZXF1ZXN0cywgd2Ugc3RhcnQgYSBwYXJhbGxlbCB1cGxvYWQuXG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnBhcmFsbGVsVXBsb2FkcyA+IDEgfHwgX3RoaXMyLl9wYXJhbGxlbFVwbG9hZFVybHMgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5fc3RhcnRQYXJhbGxlbFVwbG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5fc3RhcnRTaW5nbGVVcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMi5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgcGFyYWxsZWxpemVkIHVwbG9hZCwgd2hlcmUgb25lIGZpbGUgaXMgc3BsaXQgaW50b1xuICAgICAqIG11bHRpcGxlIHJlcXVlc3Qgd2hpY2ggYXJlIHJ1biBpbiBwYXJhbGxlbC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UGFyYWxsZWxVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHRvdGFsU2l6ZSA9IHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcbiAgICAgIHZhciB0b3RhbFByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkcyA9IFtdO1xuICAgICAgdmFyIHBhcnRDb3VudCA9IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyAhPSBudWxsID8gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzLmxlbmd0aCA6IHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHM7IC8vIFRoZSBpbnB1dCBmaWxlIHdpbGwgYmUgc3BsaXQgaW50byBtdWx0aXBsZSBzbGljZXMgd2hpY2ggYXJlIHVwbG9hZGVkIGluIHNlcGFyYXRlXG4gICAgICAvLyByZXF1ZXN0cy4gSGVyZSB3ZSBnZW5lcmF0ZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbiBmb3IgdGhlIHNsaWNlcy5cblxuICAgICAgdmFyIHBhcnRzID0gc3BsaXRTaXplSW50b1BhcnRzKHRoaXMuX3NvdXJjZS5zaXplLCBwYXJ0Q291bnQsIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyk7IC8vIENyZWF0ZSBhbiBlbXB0eSBsaXN0IGZvciBzdG9yaW5nIHRoZSB1cGxvYWQgVVJMc1xuXG4gICAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBuZXcgQXJyYXkocGFydHMubGVuZ3RoKTsgLy8gR2VuZXJhdGUgYSBwcm9taXNlIGZvciBlYWNoIHNsaWNlIHRoYXQgd2lsbCBiZSByZXNvbHZlIGlmIHRoZSByZXNwZWN0aXZlXG4gICAgICAvLyB1cGxvYWQgaXMgY29tcGxldGVkLlxuXG4gICAgICB2YXIgdXBsb2FkcyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3RQYXJ0UHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9zb3VyY2Uuc2xpY2UocGFydC5zdGFydCwgcGFydC5lbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB3aXRoIHRoZSB1c2VyIHN1cHBsaWVkIG9wdGlvbnMgYnV0IG92ZXJ3cml0ZSBzb21lIHZhbHVlcy5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgLy8gSWYgYXZhaWxhYmxlLCB0aGUgcGFydGlhbCB1cGxvYWQgc2hvdWxkIGJlIHJlc3VtZWQgZnJvbSBhIHByZXZpb3VzIFVSTC5cbiAgICAgICAgICAgICAgdXBsb2FkVXJsOiBwYXJ0LnVwbG9hZFVybCB8fCBudWxsLFxuICAgICAgICAgICAgICAvLyBXZSB0YWtlIG1hbnVhbGx5IGNhcmUgb2YgcmVzdW1pbmcgZm9yIHBhcnRpYWwgdXBsb2Fkcywgc28gdGhleSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gbm90IGJlIHN0b3JlZCBpbiB0aGUgVVJMIHN0b3JhZ2UuXG4gICAgICAgICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gdG8gbm90IGNhdXNlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICAgICAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyIHRvIGluZGljYXRlIHRoZSB0aGlzIGlzIGEgcGFydGlhbCB1cGxvYWQuXG4gICAgICAgICAgICAgIGhlYWRlcnM6IF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBcIlVwbG9hZC1Db25jYXRcIjogXCJwYXJ0aWFsXCJcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC8vIFJlamVjdCBvciByZXNvbHZlIHRoZSBwcm9taXNlIGlmIHRoZSB1cGxvYWQgZXJyb3JzIG9yIGNvbXBsZXRlcy5cbiAgICAgICAgICAgICAgb25TdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgIC8vIEJhc2VkIGluIHRoZSBwcm9ncmVzcyBmb3IgdGhpcyBwYXJ0aWFsIHVwbG9hZCwgY2FsY3VsYXRlIHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgICAvLyBmb3IgdGhlIGVudGlyZSBmaW5hbCB1cGxvYWQuXG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MobmV3UGFydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IHRvdGFsUHJvZ3Jlc3MgLSBsYXN0UGFydFByb2dyZXNzICsgbmV3UGFydFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGxhc3RQYXJ0UHJvZ3Jlc3MgPSBuZXdQYXJ0UHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICBfdGhpczMuX2VtaXRQcm9ncmVzcyh0b3RhbFByb2dyZXNzLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGV2ZXJ5IHBhcnRpYWwgdXBsb2FkIGhhcyBhbiB1cGxvYWQgVVJMLCBzbyB3ZSBjYW4gYWRkXG4gICAgICAgICAgICAgIC8vIHRoZW0gdG8gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IGZ1bmN0aW9uIF9vblVwbG9hZFVybEF2YWlsYWJsZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJsc1tpbmRleF0gPSB1cGxvYWQudXJsOyAvLyBUZXN0IGlmIGFsbCB1cGxvYWRzIGhhdmUgcmVjZWl2ZWQgYW4gVVJMXG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHMuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gISF1O1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczMuX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBsb2FkID0gbmV3IEJhc2VVcGxvYWQodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdXBsb2FkLnN0YXJ0KCk7IC8vIFN0b3JlIHRoZSB1cGxvYWQgaW4gYW4gYXJyYXksIHNvIHdlIGNhbiBsYXRlciBhYm9ydCB0aGVtIGlmIG5lY2Vzc2FyeS5cblxuICAgICAgICAgICAgX3RoaXMzLl9wYXJhbGxlbFVwbG9hZHMucHVzaCh1cGxvYWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlcTsgLy8gV2FpdCB1bnRpbCBhbGwgcGFydGlhbCB1cGxvYWRzIGFyZSBmaW5pc2hlZCBhbmQgd2UgY2FuIHNlbmQgdGhlIFBPU1QgcmVxdWVzdCBmb3JcbiAgICAgIC8vIGNyZWF0aW5nIHRoZSBmaW5hbCB1cGxvYWQuXG5cbiAgICAgIFByb21pc2UuYWxsKHVwbG9hZHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXEgPSBfdGhpczMuX29wZW5SZXF1ZXN0KFwiUE9TVFwiLCBfdGhpczMub3B0aW9ucy5lbmRwb2ludCk7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtQ29uY2F0XCIsIFwiZmluYWw7XCIuY29uY2F0KF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmpvaW4oXCIgXCIpKSk7IC8vIEFkZCBtZXRhZGF0YSBpZiB2YWx1ZXMgaGF2ZSBiZWVuIGFkZGVkXG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gZW5jb2RlTWV0YWRhdGEoX3RoaXMzLm9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gXCJcIikge1xuICAgICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTWV0YWRhdGFcIiwgbWV0YWRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWRcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuZ2V0SGVhZGVyKFwiTG9jYXRpb25cIik7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczMuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnVybCA9IHJlc29sdmVVcmwoX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczMudXJsKSk7XG5cbiAgICAgICAgX3RoaXMzLl9lbWl0U3VjY2VzcygpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMy5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgbm9uLXBhcmFsbGVsIHVwbG9hZC4gSGVyZSB0aGUgZW50aXJlIGZpbGUgaXNcbiAgICAgKiB1cGxvYWRlZCBpbiBhIHNlcXVlbnRpYWwgbWF0dGVyLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTaW5nbGVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U2luZ2xlVXBsb2FkKCkge1xuICAgICAgLy8gRmlyc3QsIHdlIGxvb2sgYXQgdGhlIHVwbG9hZExlbmd0aERlZmVycmVkIG9wdGlvbi5cbiAgICAgIC8vIE5leHQsIHdlIGNoZWNrIGlmIHRoZSBjYWxsZXIgaGFzIHN1cHBsaWVkIGEgbWFudWFsIHVwbG9hZCBzaXplLlxuICAgICAgLy8gRmluYWxseSwgd2UgdHJ5IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCBzaXplIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSArdGhpcy5vcHRpb25zLnVwbG9hZFNpemU7XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuX3NpemUpKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGNvbnZlcnQgYHVwbG9hZFNpemVgIG9wdGlvbiBpbnRvIGEgbnVtYmVyXCIpKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaXplID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgYXV0b21hdGljYWxseSBkZXJpdmUgdXBsb2FkJ3Mgc2l6ZSBmcm9tIGlucHV0IGFuZCBtdXN0IGJlIHNwZWNpZmllZCBtYW51YWxseSB1c2luZyB0aGUgYHVwbG9hZFNpemVgIG9wdGlvblwiKSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVzZXQgdGhlIGFib3J0ZWQgZmxhZyB3aGVuIHRoZSB1cGxvYWQgaXMgc3RhcnRlZCBvciBlbHNlIHRoZVxuICAgICAgLy8gX3BlcmZvcm1VcGxvYWQgd2lsbCBzdG9wIGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuXG4gICAgICAvLyBhYm9ydGVkIHByZXZpb3VzbHkuXG5cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgdXBsb2FkIGhhZCBiZWVuIHN0YXJ0ZWQgcHJldmlvdXNseSBhbmQgd2Ugc2hvdWxkIHJldXNlIHRoaXMgVVJMLlxuXG4gICAgICBpZiAodGhpcy51cmwgIT0gbnVsbCkge1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiUmVzdW1pbmcgdXBsb2FkIGZyb20gcHJldmlvdXMgVVJMOiBcIi5jb25jYXQodGhpcy51cmwpKTtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEEgVVJMIGhhcyBtYW51YWxseSBiZWVuIHNwZWNpZmllZCwgc28gd2UgdHJ5IHRvIHJlc3VtZVxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkVXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByb3ZpZGVkIFVSTDogXCIuY29uY2F0KHRoaXMub3B0aW9ucy51cmwpKTtcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLm9wdGlvbnMudXBsb2FkVXJsO1xuXG4gICAgICAgIHRoaXMuX3Jlc3VtZVVwbG9hZCgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQW4gdXBsb2FkIGhhcyBub3Qgc3RhcnRlZCBmb3IgdGhlIGZpbGUgeWV0LCBzbyB3ZSBzdGFydCBhIG5ldyBvbmVcblxuXG4gICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ3JlYXRpbmcgYSBuZXcgdXBsb2FkXCIpO1xuXG4gICAgICB0aGlzLl9jcmVhdGVVcGxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgYW55IHJ1bm5pbmcgcmVxdWVzdCBhbmQgc3RvcCB0aGUgY3VycmVudCB1cGxvYWQuIEFmdGVyIGFib3J0IGlzIGNhbGxlZCwgbm8gZXZlbnRcbiAgICAgKiBoYW5kbGVyIHdpbGwgYmUgaW52b2tlZCBhbnltb3JlLiBZb3UgY2FuIHVzZSB0aGUgYHN0YXJ0YCBtZXRob2QgdG8gcmVzdW1lIHRoZSB1cGxvYWRcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKiBJZiBgc2hvdWxkVGVybWluYXRlYCBpcyB0cnVlLCB0aGUgYHRlcm1pbmF0ZWAgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIHRoZVxuICAgICAqIGN1cnJlbnQgdXBsb2FkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkVGVybWluYXRlIFRydWUgaWYgdGhlIHVwbG9hZCBzaG91bGQgYmUgZGVsZXRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gVGhlIFByb21pc2Ugd2lsbCBiZSByZXNvbHZlZC9yZWplY3RlZCB3aGVuIHRoZSByZXF1ZXN0cyBmaW5pc2guXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYm9ydChzaG91bGRUZXJtaW5hdGUsIGNiKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR1czogdGhlIGFib3J0IGZ1bmN0aW9uIGRvZXMgbm90IGFjY2VwdCBhIGNhbGxiYWNrIHNpbmNlIHYyIGFueW1vcmU7IHBsZWFzZSB1c2UgdGhlIHJldHVybmVkIFByb21pc2UgaW5zdGVhZFwiKTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgcGFyYWxsZWwgcGFydGlhbCB1cGxvYWRzLCB0aGF0IGhhdmUgYmVlbiBzdGFydGVkIGluIF9zdGFydFBhcmFsbGVsVXBsb2Fkcy5cblxuXG4gICAgICBpZiAodGhpcy5fcGFyYWxsZWxVcGxvYWRzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzLmZvckVhY2goZnVuY3Rpb24gKHVwbG9hZCkge1xuICAgICAgICAgIHVwbG9hZC5hYm9ydChzaG91bGRUZXJtaW5hdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU3RvcCBhbnkgY3VycmVudCBydW5uaW5nIHJlcXVlc3QuXG5cblxuICAgICAgaWYgKHRoaXMuX3JlcSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7IC8vIFN0b3AgYW55IHRpbWVvdXQgdXNlZCBmb3IgaW5pdGlhdGluZyBhIHJldHJ5LlxuXG4gICAgICBpZiAodGhpcy5fcmV0cnlUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JldHJ5VGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2hvdWxkVGVybWluYXRlIHx8IHRoaXMudXJsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQmFzZVVwbG9hZC50ZXJtaW5hdGUodGhpcy51cmwsIHRoaXMub3B0aW9ucykgLy8gUmVtb3ZlIGVudHJ5IGZyb20gdGhlIFVSTCBzdG9yYWdlIHNpbmNlIHRoZSB1cGxvYWQgVVJMIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEh0dHBFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgbWVzc2FnZSwgY2F1c2luZ0Vycikge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBfZXJyb3IuZGVmYXVsdChtZXNzYWdlLCBjYXVzaW5nRXJyLCByZXEsIHJlcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdEVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0RXJyb3IoZXJyKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpczsgLy8gRG8gbm90IGVtaXQgZXJyb3JzLCBlLmcuIGZyb20gYWJvcnRlZCBIVFRQIHJlcXVlc3RzLCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuIHN0b3BwZWQuXG5cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybjsgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5LCB3aGVuIGVuYWJsZWQsIGJlZm9yZSBzZW5kaW5nIHRoZSBlcnJvciB0byB0aGUgdXNlci5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cyAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZlxuICAgICAgICAvLyAtIHdlIHdlcmUgYWxyZWFkeSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHNlcnZlciAob2Zmc2V0ICE9IG51bGwpIGFuZFxuICAgICAgICAvLyAtIHdlIHdlcmUgYWJsZSB0byB1cGxvYWQgYSBzbWFsbCBjaHVuayBvZiBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgdmFyIHNob3VsZFJlc2V0RGVsYXlzID0gdGhpcy5fb2Zmc2V0ICE9IG51bGwgJiYgdGhpcy5fb2Zmc2V0ID4gdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnk7XG5cbiAgICAgICAgaWYgKHNob3VsZFJlc2V0RGVsYXlzKSB7XG4gICAgICAgICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRSZXRyeShlcnIsIHRoaXMuX3JldHJ5QXR0ZW1wdCwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5c1t0aGlzLl9yZXRyeUF0dGVtcHQrK107XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0QmVmb3JlUmV0cnkgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczUuc3RhcnQoKTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25FcnJvcihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIGlmIHRoZSB1cGxvYWQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRTdWNjZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0U3VjY2VzcygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludC4gVGhpcyBjYXVzZXNcbiAgICAgICAgLy8gbmV3IHVwbG9hZHMgb2YgdGhlIHNhbWUgZmlsZSB0byBiZSB0cmVhdGVkIGFzIGEgZGlmZmVyZW50IGZpbGUuXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGUgc2VydmVyLiBUaGlzXG4gICAgICogZGF0YSBtYXkgbm90IGhhdmUgYmVlbiBhY2NlcHRlZCBieSB0aGUgc2VydmVyIHlldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1NlbnQgIE51bWJlciBvZiBieXRlcyBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0UHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRQcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoZXMgbm90aWZpY2F0aW9uIHdoZW4gYSBjaHVuayBvZiBkYXRhIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAqIGFuZCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgIFNpemUgb2YgdGhlIGNodW5rIHRoYXQgd2FzIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzQWNjZXB0ZWQgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0Q2h1bmtDb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdENodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25DaHVua0NvbXBsZXRlKGNodW5rU2l6ZSwgYnl0ZXNBY2NlcHRlZCwgYnl0ZXNUb3RhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB1cGxvYWQgdXNpbmcgdGhlIGNyZWF0aW9uIGV4dGVuc2lvbiBieSBzZW5kaW5nIGEgUE9TVFxuICAgICAqIHJlcXVlc3QgdG8gdGhlIGVuZHBvaW50LiBBZnRlciBzdWNjZXNzZnVsIGNyZWF0aW9uIHRoZSBmaWxlIHdpbGwgYmVcbiAgICAgKiB1cGxvYWRlZFxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5kcG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogdW5hYmxlIHRvIGNyZWF0ZSB1cGxvYWQgYmVjYXVzZSBubyBlbmRwb2ludCBpcyBwcm92aWRlZFwiKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJQT1NUXCIsIHRoaXMub3B0aW9ucy5lbmRwb2ludCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1EZWZlci1MZW5ndGhcIiwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiLCB0aGlzLl9zaXplKTtcbiAgICAgIH0gLy8gQWRkIG1ldGFkYXRhIGlmIHZhbHVlcyBoYXZlIGJlZW4gYWRkZWRcblxuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBlbmNvZGVNZXRhZGF0YSh0aGlzLm9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICBpZiAobWV0YWRhdGEgIT09IFwiXCIpIHtcbiAgICAgICAgcmVxLnNldEhlYWRlcihcIlVwbG9hZC1NZXRhZGF0YVwiLCBtZXRhZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbiAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgICAgIHByb21pc2UgPSB0aGlzLl9hZGRDaHVua1RvUmVxdWVzdChyZXEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShyZXMuZ2V0U3RhdHVzKCksIDIwMCkpIHtcbiAgICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZFwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5nZXRIZWFkZXIoXCJMb2NhdGlvblwiKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXJcIik7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczYudXJsID0gcmVzb2x2ZVVybChfdGhpczYub3B0aW9ucy5lbmRwb2ludCwgbG9jYXRpb24pO1xuICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ3JlYXRlZCB1cGxvYWQgYXQgXCIuY29uY2F0KF90aGlzNi51cmwpKTtcblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzNi5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgX3RoaXM2Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM2Ll9zaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gTm90aGluZyB0byB1cGxvYWQgYW5kIGZpbGUgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkXG4gICAgICAgICAgX3RoaXM2Ll9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgICAgX3RoaXM2Ll9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNi5fc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpO1xuXG4gICAgICAgIGlmIChfdGhpczYub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24pIHtcbiAgICAgICAgICBfdGhpczYuX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczYuX29mZnNldCA9IDA7XG5cbiAgICAgICAgICBfdGhpczYuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsIFwidHVzOiBmYWlsZWQgdG8gY3JlYXRlIHVwbG9hZFwiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogVHJ5IHRvIHJlc3VtZSBhbiBleGlzdGluZyB1cGxvYWQuIEZpcnN0IGEgSEVBRCByZXF1ZXN0IHdpbGwgYmUgc2VudFxuICAgICAqIHRvIHJldHJpZXZlIHRoZSBvZmZzZXQuIElmIHRoZSByZXF1ZXN0IGZhaWxzIGEgbmV3IHVwbG9hZCB3aWxsIGJlXG4gICAgICogY3JlYXRlZC4gSW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN1bWVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3VtZVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJIRUFEXCIsIHRoaXMudXJsKTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9zZW5kUmVxdWVzdChyZXEsIG51bGwpO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICB2YXIgc3RhdHVzID0gcmVzLmdldFN0YXR1cygpO1xuXG4gICAgICAgIGlmICghaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDIwMCkpIHtcbiAgICAgICAgICBpZiAoaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDQwMCkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQsXG4gICAgICAgICAgICAvLyBvbiBjbGllbnQgZXJyb3JzIHNpbmNlIHRoZSBmaWxlIGNhbiBub3QgYmUgZm91bmRcbiAgICAgICAgICAgIF90aGlzNy5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSB1cGxvYWQgaXMgbG9ja2VkIChpbmRpY2F0ZWQgYnkgdGhlIDQyMyBMb2NrZWQgc3RhdHVzIGNvZGUpLCB3ZVxuICAgICAgICAgIC8vIGVtaXQgYW4gZXJyb3IgaW5zdGVhZCBvZiBkaXJlY3RseSBzdGFydGluZyBhIG5ldyB1cGxvYWQuIFRoaXMgd2F5IHRoZVxuICAgICAgICAgIC8vIHJldHJ5IGxvZ2ljIGNhbiBjYXRjaCB0aGUgZXJyb3IgYW5kIHdpbGwgcmV0cnkgdGhlIHVwbG9hZC4gQW4gdXBsb2FkXG4gICAgICAgICAgLy8gaXMgdXN1YWxseSBsb2NrZWQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgYW5kIHdpbGwgYmUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYWZ0ZXJ3YXJkcy5cblxuXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDIzKSB7XG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1cGxvYWQgaXMgY3VycmVudGx5IGxvY2tlZDsgcmV0cnkgbGF0ZXJcIik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzNy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWQgaWYgbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiB1bmFibGUgdG8gcmVzdW1lIHVwbG9hZCAobmV3IHVwbG9hZCBjYW5ub3QgYmUgY3JlYXRlZCB3aXRob3V0IGFuIGVuZHBvaW50KVwiKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWRcblxuXG4gICAgICAgICAgX3RoaXM3LnVybCA9IG51bGw7XG5cbiAgICAgICAgICBfdGhpczcuX2NyZWF0ZVVwbG9hZCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIpLCAxMCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIFwidHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlSW50KHJlcy5nZXRIZWFkZXIoXCJVcGxvYWQtTGVuZ3RoXCIpLCAxMCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKGxlbmd0aCkgJiYgIV90aGlzNy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIGxlbmd0aCB2YWx1ZVwiKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXM3Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBfdGhpczcub3B0aW9ucy5fb25VcGxvYWRVcmxBdmFpbGFibGUoKTtcbiAgICAgICAgfSAvLyBVcGxvYWQgaGFzIGFscmVhZHkgYmVlbiBjb21wbGV0ZWQgYW5kIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQgYWRkaXRpb25hbFxuICAgICAgICAvLyBkYXRhIHRvIHRoZSBzZXJ2ZXJcblxuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgIF90aGlzNy5fZW1pdFByb2dyZXNzKGxlbmd0aCwgbGVuZ3RoKTtcblxuICAgICAgICAgIF90aGlzNy5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICAgIF90aGlzNy5fcGVyZm9ybVVwbG9hZCgpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsIFwidHVzOiBmYWlsZWQgdG8gcmVzdW1lIHVwbG9hZFwiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHVwbG9hZGluZyB0aGUgZmlsZSB1c2luZyBQQVRDSCByZXF1ZXN0cy4gVGhlIGZpbGUgd2lsbCBiZSBkaXZpZGVkXG4gICAgICogaW50byBjaHVua3MgYXMgc3BlY2lmaWVkIGluIHRoZSBjaHVua1NpemUgb3B0aW9uLiBEdXJpbmcgdGhlIHVwbG9hZFxuICAgICAqIHRoZSBvblByb2dyZXNzIGV2ZW50IGhhbmRsZXIgbWF5IGJlIGludm9rZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7IC8vIElmIHRoZSB1cGxvYWQgaGFzIGJlZW4gYWJvcnRlZCwgd2Ugd2lsbCBub3Qgc2VuZCB0aGUgbmV4dCBQQVRDSCByZXF1ZXN0LlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgdGhlIGFib3J0IG1ldGhvZCB3YXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrLCBzdWNoXG4gICAgICAvLyBhcyBvbkNodW5rQ29tcGxldGUgb3Igb25Qcm9ncmVzcy5cblxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXE7IC8vIFNvbWUgYnJvd3NlciBhbmQgc2VydmVycyBtYXkgbm90IHN1cHBvcnQgdGhlIFBBVENIIG1ldGhvZC4gRm9yIHRob3NlXG4gICAgICAvLyBjYXNlcywgeW91IGNhbiB0ZWxsIHR1cy1qcy1jbGllbnQgdG8gdXNlIGEgUE9TVCByZXF1ZXN0IHdpdGggdGhlXG4gICAgICAvLyBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlIGhlYWRlciBmb3Igc2ltdWxhdGluZyBhIFBBVENIIHJlcXVlc3QuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcnJpZGVQYXRjaE1ldGhvZCkge1xuICAgICAgICByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdChcIlBPU1RcIiwgdGhpcy51cmwpO1xuICAgICAgICByZXEuc2V0SGVhZGVyKFwiWC1IVFRQLU1ldGhvZC1PdmVycmlkZVwiLCBcIlBBVENIXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoXCJQQVRDSFwiLCB0aGlzLnVybCk7XG4gICAgICB9XG5cbiAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIsIHRoaXMuX29mZnNldCk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QocmVxKTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzOC5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgdXBsb2FkaW5nIGNodW5rXCIpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gRG9uJ3QgZW1pdCBhbiBlcnJvciBpZiB0aGUgdXBsb2FkIHdhcyBhYm9ydGVkIG1hbnVhbGx5XG4gICAgICAgIGlmIChfdGhpczguX2Fib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIHVwbG9hZCBjaHVuayBhdCBvZmZzZXQgXCIgKyBfdGhpczguX29mZnNldCwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfYWRkQ2h1bmt0b1JlcXVlc3QgcmVhZHMgYSBjaHVuayBmcm9tIHRoZSBzb3VyY2UgYW5kIHNlbmRzIGl0IHVzaW5nIHRoZVxuICAgICAqIHN1cHBsaWVkIHJlcXVlc3Qgb2JqZWN0LiBJdCB3aWxsIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ2h1bmtUb1JlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENodW5rVG9SZXF1ZXN0KHJlcSkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vZmZzZXQgKyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgcmVxLnNldFByb2dyZXNzSGFuZGxlcihmdW5jdGlvbiAoYnl0ZXNTZW50KSB7XG4gICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKHN0YXJ0ICsgYnl0ZXNTZW50LCBfdGhpczkuX3NpemUpO1xuICAgICAgfSk7XG4gICAgICByZXEuc2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTsgLy8gVGhlIHNwZWNpZmllZCBjaHVua1NpemUgbWF5IGJlIEluZmluaXR5IG9yIHRoZSBjYWxjbHVhdGVkIGVuZCBwb3NpdGlvblxuICAgICAgLy8gbWF5IGV4Y2VlZCB0aGUgZmlsZSdzIHNpemUuIEluIGJvdGggY2FzZXMsIHdlIGxpbWl0IHRoZSBlbmQgcG9zaXRpb24gdG9cbiAgICAgIC8vIHRoZSBpbnB1dCdzIHRvdGFsIHNpemUgZm9yIHNpbXBsZXIgY2FsY3VsYXRpb25zIGFuZCBjb3JyZWN0bmVzcy5cblxuICAgICAgaWYgKChlbmQgPT09IEluZmluaXR5IHx8IGVuZCA+IHRoaXMuX3NpemUpICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgZW5kID0gdGhpcy5fc2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5zbGljZShzdGFydCwgZW5kKS50aGVuKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgICAgICAgIGRvbmUgPSBfcmVmMi5kb25lOyAvLyBJZiB0aGUgdXBsb2FkIGxlbmd0aCBpcyBkZWZlcnJlZCwgdGhlIHVwbG9hZCBzaXplIHdhcyBub3Qgc3BlY2lmaWVkIGR1cmluZ1xuICAgICAgICAvLyB1cGxvYWQgY3JlYXRpb24uIFNvLCBpZiB0aGUgZmlsZSByZWFkZXIgaXMgZG9uZSByZWFkaW5nLCB3ZSBrbm93IHRoZSB0b3RhbFxuICAgICAgICAvLyB1cGxvYWQgc2l6ZSBhbmQgY2FuIHRlbGwgdGhlIHR1cyBzZXJ2ZXIuXG5cbiAgICAgICAgaWYgKF90aGlzOS5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkICYmIGRvbmUpIHtcbiAgICAgICAgICBfdGhpczkuX3NpemUgPSBfdGhpczkuX29mZnNldCArICh2YWx1ZSAmJiB2YWx1ZS5zaXplID8gdmFsdWUuc2l6ZSA6IDApO1xuICAgICAgICAgIHJlcS5zZXRIZWFkZXIoXCJVcGxvYWQtTGVuZ3RoXCIsIF90aGlzOS5fc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM5Ll9zZW5kUmVxdWVzdChyZXEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKF90aGlzOS5fb2Zmc2V0LCBfdGhpczkuX3NpemUpO1xuXG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfaGFuZGxlVXBsb2FkUmVzcG9uc2UgaXMgdXNlZCBieSByZXF1ZXN0cyB0aGF0IGhhdmVuIGJlZW4gc2VudCB1c2luZyBfYWRkQ2h1bmtUb1JlcXVlc3RcbiAgICAgKiBhbmQgYWxyZWFkeSBoYXZlIHJlY2VpdmVkIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVVcGxvYWRSZXNwb25zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBsb2FkUmVzcG9uc2UocmVxLCByZXMpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSwgMTApO1xuXG4gICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aGlzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCBcInR1czogaW52YWxpZCBvciBtaXNzaW5nIG9mZnNldCB2YWx1ZVwiKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VtaXRQcm9ncmVzcyhvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9lbWl0Q2h1bmtDb21wbGV0ZShvZmZzZXQgLSB0aGlzLl9vZmZzZXQsIG9mZnNldCwgdGhpcy5fc2l6ZSk7XG5cbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcblxuICAgICAgaWYgKG9mZnNldCA9PSB0aGlzLl9zaXplKSB7XG4gICAgICAgIC8vIFlheSwgZmluYWxseSBkb25lIDopXG4gICAgICAgIHRoaXMuX2VtaXRTdWNjZXNzKCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZXJmb3JtVXBsb2FkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1ldGhvZCBhbmQgVVJMLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgICB2YXIgcmVxID0gb3BlblJlcXVlc3QobWV0aG9kLCB1cmwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLl9yZXEgPSByZXE7XG4gICAgICByZXR1cm4gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGVudHJ5IGluIHRoZSBVUkwgc3RvcmFnZSwgaWYgaXQgaGFzIGJlZW4gc2F2ZWQgYmVmb3JlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlRnJvbVVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21VcmxTdG9yYWdlKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuX3VybFN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQodGhpcy5fdXJsU3RvcmFnZUtleSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTAuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VybFN0b3JhZ2VLZXkgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHVwbG9hZCBVUkwgdG8gdGhlIFVSTCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVVcGxvYWRJblVybFN0b3JhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmVVcGxvYWRJblVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7IC8vIE9ubHkgaWYgYSBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBmb3IgdGhlIGlucHV0IChpLmUuIG5vdCBhIHN0cmVhbSksIHdlIGNhbiBzdG9yZSB0aGUgdXBsb2FkIFVSTC5cblxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmcgfHwgIXRoaXMuX2ZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3JlZFVwbG9hZCA9IHtcbiAgICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgICAgbWV0YWRhdGE6IHRoaXMub3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9wYXJhbGxlbFVwbG9hZHMpIHtcbiAgICAgICAgLy8gU2F2ZSBtdWx0aXBsZSBVUkxzIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQgLi4uXG4gICAgICAgIHN0b3JlZFVwbG9hZC5wYXJhbGxlbFVwbG9hZFVybHMgPSB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIHdlIGp1c3Qgc2F2ZSB0aGUgb25lIGF2YWlsYWJsZSBVUkwuXG4gICAgICAgIHN0b3JlZFVwbG9hZC51cGxvYWRVcmwgPSB0aGlzLnVybDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZS5hZGRVcGxvYWQodGhpcy5fZmluZ2VycHJpbnQsIHN0b3JlZFVwbG9hZCkudGhlbihmdW5jdGlvbiAodXJsU3RvcmFnZUtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMS5fdXJsU3RvcmFnZUtleSA9IHVybFN0b3JhZ2VLZXk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMxMS5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYm9keSB3aGlsZSBpbnZva2luZyB0aGUgb25CZWZvcmVSZXF1ZXN0XG4gICAgICogYW5kIG9uQWZ0ZXJSZXNwb25zZSBjYWxsYmFja3MuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZW5kUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VuZFJlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICAgIHZhciBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25CZWZvcmVSZXF1ZXN0KHJlcSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXEuc2VuZChib2R5KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczEyLm9wdGlvbnMub25BZnRlclJlc3BvbnNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBfdGhpczEyLm9wdGlvbnMub25BZnRlclJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVybWluYXRlKHVybCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR1czogdGhlIHRlcm1pbmF0ZSBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgYSBjYWxsYmFjayBzaW5jZSB2MiBhbnltb3JlOyBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBQcm9taXNlIGluc3RlYWRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXEgPSBvcGVuUmVxdWVzdChcIkRFTEVURVwiLCB1cmwsIG9wdGlvbnMpO1xuICAgICAgdmFyIHByb21pc2UgPSByZXEuc2VuZCgpO1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIEEgMjA0IHJlc3BvbnNlIGluZGljYXRlcyBhIHN1Y2Nlc3NmdWxsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcy5nZXRTdGF0dXMoKSA9PT0gMjA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IF9lcnJvci5kZWZhdWx0KFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHRlcm1pbmF0aW5nIHVwbG9hZFwiLCBudWxsLCByZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgX2Vycm9yLmRlZmF1bHQpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IF9lcnJvci5kZWZhdWx0KFwidHVzOiBmYWlsZWQgdG8gdGVybWluYXRlIHVwbG9hZFwiLCBlcnIsIHJlcSwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgMCwgb3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gLy8gSW5zdGVhZCBvZiBrZWVwaW5nIHRyYWNrIG9mIHRoZSByZXRyeSBhdHRlbXB0cywgd2UgcmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGRlbGF5c1xuICAgICAgICAvLyBhcnJheS4gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCBhbGwgcmV0cnkgYXR0ZW1wdHMgYXJlIHVzZWQgdXAgYW5kIHdlIHdpbGwgYnViYmxlIHVwIHRoZSBlcnJvci5cbiAgICAgICAgLy8gV2UgcmVjdXJzaXZlbHkgY2FsbCB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIHdpbGwgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgcmV0cnlEZWxheXMgYXJyYXkuXG5cblxuICAgICAgICB2YXIgZGVsYXkgPSBvcHRpb25zLnJldHJ5RGVsYXlzWzBdO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVsYXlzID0gb3B0aW9ucy5yZXRyeURlbGF5cy5zbGljZSgxKTtcblxuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICByZXRyeURlbGF5czogcmVtYWluaW5nRGVsYXlzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEJhc2VVcGxvYWQudGVybWluYXRlKHVybCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VVcGxvYWQ7XG59KCk7XG5cbmZ1bmN0aW9uIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gIHZhciBlbmNvZGVkID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG1ldGFkYXRhKSB7XG4gICAgZW5jb2RlZC5wdXNoKGtleSArIFwiIFwiICsgX2pzQmFzZS5CYXNlNjQuZW5jb2RlKG1ldGFkYXRhW2tleV0pKTtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGVkLmpvaW4oXCIsXCIpO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHN0YXR1cyBpcyBpbiB0aGUgcmFuZ2Ugb2YgdGhlIGV4cGVjdGVkIGNhdGVnb3J5LlxuICogRm9yIGV4YW1wbGUsIG9ubHkgYSBzdGF0dXMgYmV0d2VlbiAyMDAgYW5kIDI5OSB3aWxsIHNhdGlzZnkgdGhlIGNhdGVnb3J5IDIwMC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCBjYXRlZ29yeSkge1xuICByZXR1cm4gc3RhdHVzID49IGNhdGVnb3J5ICYmIHN0YXR1cyA8IGNhdGVnb3J5ICsgMTAwO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSFRUUCByZXF1ZXN0IHdpdGggdGhlIHNwZWNpZmllZCBtZXRob2QgYW5kIFVSTC5cbiAqIFRoZSBuZWNlc3NhcnkgaGVhZGVycyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBldmVyeSByZXF1ZXN0XG4gKiB3aWxsIGJlIGFkZGVkLCBpbmNsdWRpbmcgdGhlIHJlcXVlc3QgSUQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBvcGVuUmVxdWVzdChtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICB2YXIgcmVxID0gb3B0aW9ucy5odHRwU3RhY2suY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCk7XG4gIHJlcS5zZXRIZWFkZXIoXCJUdXMtUmVzdW1hYmxlXCIsIFwiMS4wLjBcIik7XG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgIHJlcS5zZXRIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hZGRSZXF1ZXN0SWQpIHtcbiAgICB2YXIgcmVxdWVzdElkID0gKDAsIF91dWlkLmRlZmF1bHQpKCk7XG4gICAgcmVxLnNldEhlYWRlcihcIlgtUmVxdWVzdC1JRFwiLCByZXF1ZXN0SWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlcTtcbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGJyb3dzZXIgcnVubmluZyB0aGlzIGNvZGUgaGFzIGludGVybmV0IGFjY2Vzcy5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbHdheXMgcmV0dXJuIHRydWUgaW4gdGhlIG5vZGUuanMgZW52aXJvbm1lbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT25saW5lKCkge1xuICB2YXIgb25saW5lID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIm5hdmlnYXRvclwiIGluIHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA9PT0gZmFsc2UpIHtcbiAgICBvbmxpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBvbmxpbmU7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBvayB0byByZXRyeSBhIHJlcXVlc3QuXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgdGhlIGVycm9yIHJldHVybmVkIGZyb20gdGhlIGxhc3QgcmVxdWVzdFxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5QXR0ZW1wdCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmV0cmllZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdHVzIFVwbG9hZCBvcHRpb25zXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnIsIHJldHJ5QXR0ZW1wdCwgb3B0aW9ucykge1xuICAvLyBXZSBvbmx5IGF0dGVtcHQgYSByZXRyeSBpZlxuICAvLyAtIHJldHJ5RGVsYXlzIG9wdGlvbiBpcyBzZXRcbiAgLy8gLSB3ZSBkaWRuJ3QgZXhjZWVkIHRoZSBtYXhpdW0gbnVtYmVyIG9mIHJldHJpZXMsIHlldCwgYW5kXG4gIC8vIC0gdGhpcyBlcnJvciB3YXMgY2F1c2VkIGJ5IGEgcmVxdWVzdCBvciBpdCdzIHJlc3BvbnNlIGFuZFxuICAvLyAtIHRoZSBlcnJvciBpcyBzZXJ2ZXIgZXJyb3IgKGkuZS4gbm8gYSBzdGF0dXMgNHh4IG9yIGEgNDA5IG9yIDQyMykgYW5kXG4gIC8vIC0gdGhlIGJyb3dzZXIgZG9lcyBub3QgaW5kaWNhdGUgdGhhdCB3ZSBhcmUgb2ZmbGluZVxuICB2YXIgc3RhdHVzID0gZXJyLm9yaWdpbmFsUmVzcG9uc2UgPyBlcnIub3JpZ2luYWxSZXNwb25zZS5nZXRTdGF0dXMoKSA6IDA7XG4gIHZhciBpc1NlcnZlckVycm9yID0gIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApIHx8IHN0YXR1cyA9PT0gNDA5IHx8IHN0YXR1cyA9PT0gNDIzO1xuICByZXR1cm4gb3B0aW9ucy5yZXRyeURlbGF5cyAhPSBudWxsICYmIHJldHJ5QXR0ZW1wdCA8IG9wdGlvbnMucmV0cnlEZWxheXMubGVuZ3RoICYmIGVyci5vcmlnaW5hbFJlcXVlc3QgIT0gbnVsbCAmJiBpc1NlcnZlckVycm9yICYmIGlzT25saW5lKCk7XG59XG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBsaW5rIGdpdmVuIHRoZSBvcmlnaW4gYXMgc291cmNlLiBGb3IgZXhhbXBsZSxcbiAqIGlmIGEgSFRUUCByZXF1ZXN0IHRvIGh0dHA6Ly9leGFtcGxlLmNvbS9maWxlcy8gcmV0dXJucyBhIExvY2F0aW9uXG4gKiBoZWFkZXIgd2l0aCB0aGUgdmFsdWUgL3VwbG9hZC9hYmMsIHRoZSByZXNvbHZlZCBVUkwgd2lsbCBiZTpcbiAqIGh0dHA6Ly9leGFtcGxlLmNvbS91cGxvYWQvYWJjXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKG9yaWdpbiwgbGluaykge1xuICByZXR1cm4gbmV3IF91cmxQYXJzZS5kZWZhdWx0KGxpbmssIG9yaWdpbikudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBmb3IgdGhlIHBhcnRzIGlmIGFuIHVwbG9hZFxuICogaXMgc3BsaXQgaW50byBtdWx0aXBsZSBwYXJhbGxlbCByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxTaXplIFRoZSBieXRlIHNpemUgb2YgdGhlIHVwbG9hZCwgd2hpY2ggd2lsbCBiZSBzcGxpdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0Q291bnQgVGhlIG51bWJlciBpbiBob3cgbWFueSBwYXJ0cyB0aGUgdXBsb2FkIHdpbGwgYmUgc3BsaXQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcmV2aW91c1VybHMgVGhlIHVwbG9hZCBVUkxzIGZvciBwcmV2aW91cyBwYXJ0cy5cbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdFNpemVJbnRvUGFydHModG90YWxTaXplLCBwYXJ0Q291bnQsIHByZXZpb3VzVXJscykge1xuICB2YXIgcGFydFNpemUgPSBNYXRoLmZsb29yKHRvdGFsU2l6ZSAvIHBhcnRDb3VudCk7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydENvdW50OyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBwYXJ0U2l6ZSAqIGksXG4gICAgICBlbmQ6IHBhcnRTaXplICogKGkgKyAxKVxuICAgIH0pO1xuICB9XG5cbiAgcGFydHNbcGFydENvdW50IC0gMV0uZW5kID0gdG90YWxTaXplOyAvLyBBdHRhY2ggVVJMcyBmcm9tIHByZXZpb3VzIHVwbG9hZHMsIGlmIGF2YWlsYWJsZS5cblxuICBpZiAocHJldmlvdXNVcmxzKSB7XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgIHBhcnQudXBsb2FkVXJsID0gcHJldmlvdXNVcmxzW2luZGV4XSB8fCBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5CYXNlVXBsb2FkLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG52YXIgX2RlZmF1bHQgPSBCYXNlVXBsb2FkO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB1dWlkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgVVVJRCB2NCBiYXNlZCBvbiByYW5kb20gbnVtYmVycy4gV2UgaW50ZW50aW9hbmxseSB1c2UgdGhlIGxlc3NcbiAqIHNlY3VyZSBNYXRoLnJhbmRvbSBmdW5jdGlvbiBoZXJlIHNpbmNlIHRoZSBtb3JlIHNlY3VyZSBjcnlwdG8uZ2V0UmFuZG9tTnVtYmVyc1xuICogaXMgbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zLlxuICogVGhpcyBpcyBub3QgYSBwcm9ibGVtIGZvciB1cyBzaW5jZSB3ZSB1c2UgdGhlIFVVSUQgb25seSBmb3IgZ2VuZXJhdGluZyBhXG4gKiByZXF1ZXN0IElELCBzbyB3ZSBjYW4gY29ycmVsYXRlIHNlcnZlciBsb2dzIHRvIGNsaWVudCBlcnJvcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0YWtlbiBmcm9tIGZvbGxvd2luZyBzaXRlOlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGdlbmVyYXRlIFVVSURcbiAqL1xuZnVuY3Rpb24gdXVpZCgpIHtcbiAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgdiA9IGMgPT0gXCJ4XCIgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gIH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKHV0aWxzLm1lcmdlKGRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB7bWV0aG9kOiAnZ2V0J30sIHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG4gICAgY29uZmlnLnVybCA9IGNvbWJpbmVVUkxzKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnMgfHwge31cbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgLy8gTm90ZTogc3RhdHVzIGlzIG5vdCBleHBvc2VkIGJ5IFhEb21haW5SZXF1ZXN0XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIHJlc3VsdFtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbVxufTtcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIHJvb3RQYXJlbnQgPSB7fVxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIFNhZmFyaSA1LTcgbGFja3Mgc3VwcG9ydCBmb3IgY2hhbmdpbmcgdGhlIGBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yYCBwcm9wZXJ0eVxuICogICAgIG9uIG9iamVjdHMuXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICBmdW5jdGlvbiBCYXIgKCkge31cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIGFyci5jb25zdHJ1Y3RvciA9IEJhclxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIGFyci5jb25zdHJ1Y3RvciA9PT0gQmFyICYmIC8vIGNvbnN0cnVjdG9yIGNhbiBiZSBzZXRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgLy8gQXZvaWQgZ29pbmcgdGhyb3VnaCBhbiBBcmd1bWVudHNBZGFwdG9yVHJhbXBvbGluZSBpbiB0aGUgY29tbW9uIGNhc2UuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGFyZ3VtZW50c1sxXSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLCBhcmcpXG4gIH1cblxuICAvLyBTbGlnaHRseSBsZXNzIGNvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGlzLCBhcmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogJ3V0ZjgnKVxuICB9XG5cbiAgLy8gVW51c3VhbC5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhpcywgYXJnKVxufVxuXG5mdW5jdGlvbiBmcm9tTnVtYmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChsZW5ndGgpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIC8vIEFzc3VtcHRpb246IGJ5dGVMZW5ndGgoKSByZXR1cm4gdmFsdWUgaXMgYWx3YXlzIDwga01heExlbmd0aC5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSByZXR1cm4gZnJvbUJ1ZmZlcih0aGF0LCBvYmplY3QpXG5cbiAgaWYgKGlzQXJyYXkob2JqZWN0KSkgcmV0dXJuIGZyb21BcnJheSh0aGF0LCBvYmplY3QpXG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAob2JqZWN0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgb2JqZWN0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvYmplY3QubGVuZ3RoKSByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmplY3QpXG5cbiAgcmV0dXJuIGZyb21Kc29uT2JqZWN0KHRoYXQsIG9iamVjdClcbn1cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlciAodGhhdCwgYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGJ1ZmZlci5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBidWZmZXIuY29weSh0aGF0LCAwLCAwLCBsZW5ndGgpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIER1cGxpY2F0ZSBvZiBmcm9tQXJyYXkoKSB0byBrZWVwIGZyb21BcnJheSgpIG1vbm9tb3JwaGljLlxuZnVuY3Rpb24gZnJvbVR5cGVkQXJyYXkgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIC8vIFRydW5jYXRpbmcgdGhlIGVsZW1lbnRzIGlzIHByb2JhYmx5IG5vdCB3aGF0IHBlb3BsZSBleHBlY3QgZnJvbSB0eXBlZFxuICAvLyBhcnJheXMgd2l0aCBCWVRFU19QRVJfRUxFTUVOVCA+IDEgYnV0IGl0J3MgY29tcGF0aWJsZSB3aXRoIHRoZSBiZWhhdmlvclxuICAvLyBvZiB0aGUgb2xkIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXkpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbVR5cGVkQXJyYXkodGhhdCwgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpKVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vLyBEZXNlcmlhbGl6ZSB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbMSwyLDMsLi4uXSB9IGludG8gYSBCdWZmZXIgb2JqZWN0LlxuLy8gUmV0dXJucyBhIHplcm8tbGVuZ3RoIGJ1ZmZlciBmb3IgaW5wdXRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3BlYy5cbmZ1bmN0aW9uIGZyb21Kc29uT2JqZWN0ICh0aGF0LCBvYmplY3QpIHtcbiAgdmFyIGFycmF5XG4gIHZhciBsZW5ndGggPSAwXG5cbiAgaWYgKG9iamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iamVjdC5kYXRhKSkge1xuICAgIGFycmF5ID0gb2JqZWN0LmRhdGFcbiAgICBsZW5ndGggPSBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIH1cbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbn0gZWxzZSB7XG4gIC8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG4gIEJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG4gIEJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGFsbG9jYXRlICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoYXQuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGZyb21Qb29sID0gbGVuZ3RoICE9PSAwICYmIGxlbmd0aCA8PSBCdWZmZXIucG9vbFNpemUgPj4+IDFcbiAgaWYgKGZyb21Qb29sKSB0aGF0LnBhcmVudCA9IHJvb3RQYXJlbnRcblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTbG93QnVmZmVyKSkgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nKVxuICBkZWxldGUgYnVmLnBhcmVudFxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICB2YXIgaSA9IDBcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIGJyZWFrXG5cbiAgICArK2lcbiAgfVxuXG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzLicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSBzdHJpbmcgPSAnJyArIHN0cmluZ1xuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgY2FzZSAncmF3JzpcbiAgICAgIGNhc2UgJ3Jhd3MnOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgfCAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCB8IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCBpcyBkZXByZWNhdGVkXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSB2YWx1ZSA8IDAgPyAxIDogMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiB0b0FycmF5QnVmZmVyICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiBfYXVnbWVudCAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgc2V0IG1ldGhvZCBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gVGhpcyBmaWxlIGNhbiBiZSByZXF1aXJlZCBpbiBCcm93c2VyaWZ5IGFuZCBOb2RlLmpzIGZvciBhdXRvbWF0aWMgcG9seWZpbGxcbi8vIFRvIHVzZSBpdDogIHJlcXVpcmUoJ2VzNi1wcm9taXNlL2F1dG8nKTtcbid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKS5wb2x5ZmlsbCgpO1xuIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjgrMWU2OGRjZTZcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuXG4gIGlmIChfc3RhdGUpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIHRoZW4kJDEgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4kJDEgPSB2YWx1ZS50aGVuO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCB0aGVuJCQxKTtcbiAgfSBlbHNlIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gIH1cblxuICBwdWJsaXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByb21pc2UuX3Jlc3VsdCA9IHZhbHVlO1xuICBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRDtcblxuICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwcm9taXNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFJFSkVDVEVEO1xuICBwcm9taXNlLl9yZXN1bHQgPSByZWFzb247XG5cbiAgYXNhcChwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBfc3Vic2NyaWJlcnMgPSBwYXJlbnQuX3N1YnNjcmliZXJzO1xuICB2YXIgbGVuZ3RoID0gX3N1YnNjcmliZXJzLmxlbmd0aDtcblxuXG4gIHBhcmVudC5fb25lcnJvciA9IG51bGw7XG5cbiAgX3N1YnNjcmliZXJzW2xlbmd0aF0gPSBjaGlsZDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgUkVKRUNURURdID0gb25SZWplY3Rpb247XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgYXNhcChwdWJsaXNoLCBwYXJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSkge1xuICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdm9pZCAwLFxuICAgICAgY2FsbGJhY2sgPSB2b2lkIDAsXG4gICAgICBkZXRhaWwgPSBwcm9taXNlLl9yZXN1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMCxcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWNjZWVkZWQgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gZTtcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBjYW5ub3RSZXR1cm5Pd24oKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZGV0YWlsO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHN1Y2NlZWRlZCA9PT0gZmFsc2UpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbnZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuICB9XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIF9lbnVtZXJhdGUoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gX2VhY2hFbnRyeShlbnRyeSwgaSkge1xuICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuXG4gICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgICAgdmFyIF90aGVuID0gdm9pZCAwO1xuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBfdGhlbiA9IGVudHJ5LnRoZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoZW4gPT09IHRoZW4gJiYgZW50cnkuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX3RoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChjID09PSBQcm9taXNlJDEpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgYyhub29wKTtcbiAgICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIiwiLypcbiAqICBiYXNlNjQuanNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICogICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqICBSZWZlcmVuY2VzOlxuICogICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjRcbiAqL1xuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbClcbiAgICAgICAgOiB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWRcbiAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOiBmYWN0b3J5KGdsb2JhbClcbn0oKFxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsXG46IHRoaXNcbiksIGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICB2YXIgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgdmFyIHZlcnNpb24gPSBcIjIuNC45XCI7XG4gICAgLy8gaWYgbm9kZS5qcyBhbmQgTk9UIFJlYWN0IE5hdGl2ZSwgd2UgdXNlIEJ1ZmZlclxuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBidWZmZXIgPSBldmFsKFwicmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgYjY0Y2hhcnNcbiAgICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgdmFyIGI2NHRhYiA9IGZ1bmN0aW9uKGJpbikge1xuICAgICAgICB2YXIgdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJpbi5sZW5ndGg7IGkgPCBsOyBpKyspIHRbYmluLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9KGI2NGNoYXJzKTtcbiAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgICAvLyBlbmNvZGVyIHN0dWZmXG4gICAgdmFyIGNiX3V0b2IgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIGlmIChjLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHZhciBjYyA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHJldHVybiBjYyA8IDB4ODAgPyBjXG4gICAgICAgICAgICAgICAgOiBjYyA8IDB4ODAwID8gKGZyb21DaGFyQ29kZSgweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKSlcbiAgICAgICAgICAgICAgICA6IChmcm9tQ2hhckNvZGUoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKVxuICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYyA9IDB4MTAwMDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDBcbiAgICAgICAgICAgICAgICArIChjLmNoYXJDb2RlQXQoMSkgLSAweERDMDApO1xuICAgICAgICAgICAgcmV0dXJuIChmcm9tQ2hhckNvZGUoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAgNikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICggY2MgICAgICAgICAmIDB4M2YpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZV91dG9iID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRkZdfFteXFx4MDAtXFx4N0ZdL2c7XG4gICAgdmFyIHV0b2IgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1LnJlcGxhY2UocmVfdXRvYiwgY2JfdXRvYik7XG4gICAgfTtcbiAgICB2YXIgY2JfZW5jb2RlID0gZnVuY3Rpb24oY2NjKSB7XG4gICAgICAgIHZhciBwYWRsZW4gPSBbMCwgMiwgMV1bY2NjLmxlbmd0aCAlIDNdLFxuICAgICAgICBvcmQgPSBjY2MuY2hhckNvZGVBdCgwKSA8PCAxNlxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KVxuICAgICAgICAgICAgfCAoKGNjYy5sZW5ndGggPiAyID8gY2NjLmNoYXJDb2RlQXQoMikgOiAwKSksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KCBvcmQgPj4+IDE4KSxcbiAgICAgICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgICAgICBwYWRsZW4gPj0gMiA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiA2KSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAxID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KG9yZCAmIDYzKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICB2YXIgYnRvYSA9IGdsb2JhbC5idG9hID8gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsLmJ0b2EoYik7XG4gICAgfSA6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG4gICAgdmFyIF9lbmNvZGUgPSBidWZmZXIgP1xuICAgICAgICBidWZmZXIuZnJvbSAmJiBVaW50OEFycmF5ICYmIGJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb21cbiAgICAgICAgPyBmdW5jdGlvbiAodSkge1xuICAgICAgICAgICAgcmV0dXJuICh1LmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3IgPyB1IDogYnVmZmVyLmZyb20odSkpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICB9XG4gICAgICAgIDogIGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICByZXR1cm4gKHUuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvciA/IHUgOiBuZXcgIGJ1ZmZlcih1KSlcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAodSkgeyByZXR1cm4gYnRvYSh1dG9iKHUpKSB9XG4gICAgO1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbih1LCB1cmlzYWZlKSB7XG4gICAgICAgIHJldHVybiAhdXJpc2FmZVxuICAgICAgICAgICAgPyBfZW5jb2RlKFN0cmluZyh1KSlcbiAgICAgICAgICAgIDogX2VuY29kZShTdHJpbmcodSkpLnJlcGxhY2UoL1srXFwvXS9nLCBmdW5jdGlvbihtMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtMCA9PSAnKycgPyAnLScgOiAnXyc7XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC89L2csICcnKTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGVVUkkgPSBmdW5jdGlvbih1KSB7IHJldHVybiBlbmNvZGUodSwgdHJ1ZSkgfTtcbiAgICAvLyBkZWNvZGVyIHN0dWZmXG4gICAgdmFyIHJlX2J0b3UgPSBuZXcgUmVnRXhwKFtcbiAgICAgICAgJ1tcXHhDMC1cXHhERl1bXFx4ODAtXFx4QkZdJyxcbiAgICAgICAgJ1tcXHhFMC1cXHhFRl1bXFx4ODAtXFx4QkZdezJ9JyxcbiAgICAgICAgJ1tcXHhGMC1cXHhGN11bXFx4ODAtXFx4QkZdezN9J1xuICAgIF0uam9pbignfCcpLCAnZycpO1xuICAgIHZhciBjYl9idG91ID0gZnVuY3Rpb24oY2NjYykge1xuICAgICAgICBzd2l0Y2goY2NjYy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICB8ICAgICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgfCAgICAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpIDw8ICA2KVxuICAgICAgICAgICAgICAgIHwgICAgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDMpKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiAoZnJvbUNoYXJDb2RlKChvZmZzZXQgID4+PiAxMCkgKyAweEQ4MDApXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKChvZmZzZXQgJiAweDNGRikgKyAweERDMDApKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAoKDB4MGYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMikpXG4gICAgICAgICAgICApO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgKCgweDFmICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKHJlX2J0b3UsIGNiX2J0b3UpO1xuICAgIH07XG4gICAgdmFyIGNiX2RlY29kZSA9IGZ1bmN0aW9uKGNjY2MpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNjY2MubGVuZ3RoLFxuICAgICAgICBwYWRsZW4gPSBsZW4gJSA0LFxuICAgICAgICBuID0gKGxlbiA+IDAgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMCldIDw8IDE4IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDEgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMSldIDw8IDEyIDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDIgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMildIDw8ICA2IDogMClcbiAgICAgICAgICAgIHwgKGxlbiA+IDMgPyBiNjR0YWJbY2NjYy5jaGFyQXQoMyldICAgICAgIDogMCksXG4gICAgICAgIGNoYXJzID0gW1xuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuID4+PiAxNiksXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoKG4gPj4+ICA4KSAmIDB4ZmYpLFxuICAgICAgICAgICAgZnJvbUNoYXJDb2RlKCBuICAgICAgICAgJiAweGZmKVxuICAgICAgICBdO1xuICAgICAgICBjaGFycy5sZW5ndGggLT0gWzAsIDAsIDIsIDFdW3BhZGxlbl07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBhdG9iID0gZ2xvYmFsLmF0b2IgPyBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuYXRvYihhKTtcbiAgICB9IDogZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoL1tcXHNcXFNdezEsNH0vZywgY2JfZGVjb2RlKTtcbiAgICB9O1xuICAgIHZhciBfZGVjb2RlID0gYnVmZmVyID9cbiAgICAgICAgYnVmZmVyLmZyb20gJiYgVWludDhBcnJheSAmJiBidWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tXG4gICAgICAgID8gZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIChhLmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBhIDogYnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIChhLmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBhIDogbmV3IGJ1ZmZlcihhLCAnYmFzZTY0JykpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbihhKSB7IHJldHVybiBidG91KGF0b2IoYSkpIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gX2RlY29kZShcbiAgICAgICAgICAgIFN0cmluZyhhKS5yZXBsYWNlKC9bLV9dL2csIGZ1bmN0aW9uKG0wKSB7IHJldHVybiBtMCA9PSAnLScgPyAnKycgOiAnLycgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKVxuICAgICAgICApO1xuICAgIH07XG4gICAgdmFyIG5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgICAgIGdsb2JhbC5CYXNlNjQgPSBfQmFzZTY0O1xuICAgICAgICByZXR1cm4gQmFzZTY0O1xuICAgIH07XG4gICAgLy8gZXhwb3J0IEJhc2U2NFxuICAgIGdsb2JhbC5CYXNlNjQgPSB7XG4gICAgICAgIFZFUlNJT046IHZlcnNpb24sXG4gICAgICAgIGF0b2I6IGF0b2IsXG4gICAgICAgIGJ0b2E6IGJ0b2EsXG4gICAgICAgIGZyb21CYXNlNjQ6IGRlY29kZSxcbiAgICAgICAgdG9CYXNlNjQ6IGVuY29kZSxcbiAgICAgICAgdXRvYjogdXRvYixcbiAgICAgICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgICAgIGVuY29kZVVSSTogZW5jb2RlVVJJLFxuICAgICAgICBidG91OiBidG91LFxuICAgICAgICBkZWNvZGU6IGRlY29kZSxcbiAgICAgICAgbm9Db25mbGljdDogbm9Db25mbGljdCxcbiAgICAgICAgX19idWZmZXJfXzogYnVmZmVyXG4gICAgfTtcbiAgICAvLyBpZiBFUzUgaXMgYXZhaWxhYmxlLCBtYWtlIEJhc2U2NC5leHRlbmRTdHJpbmcoKSBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgbm9FbnVtID0gZnVuY3Rpb24odil7XG4gICAgICAgICAgICByZXR1cm4ge3ZhbHVlOnYsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsLkJhc2U2NC5leHRlbmRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZSwgJ2Zyb21CYXNlNjQnLCBub0VudW0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKHRoaXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NCcsIG5vRW51bShmdW5jdGlvbiAodXJpc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlKHRoaXMsIHVyaXNhZmUpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICd0b0Jhc2U2NFVSSScsIG5vRW51bShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGUodGhpcywgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vXG4gICAgLy8gZXhwb3J0IEJhc2U2NCB0byB0aGUgbmFtZXNwYWNlXG4gICAgLy9cbiAgICBpZiAoZ2xvYmFsWydNZXRlb3InXSkgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB9XG4gICAgLy8gbW9kdWxlLmV4cG9ydHMgYW5kIEFNRCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgIC8vIG1vZHVsZS5leHBvcnRzIGhhcyBwcmVjZWRlbmNlLlxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5CYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCl7IHJldHVybiBnbG9iYWwuQmFzZTY0IH0pO1xuICAgIH1cbiAgICAvLyB0aGF0J3MgaXQhXG4gICAgcmV0dXJuIHtCYXNlNjQ6IGdsb2JhbC5CYXNlNjR9XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgaWYgKGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgbG9jYXRpb24gPSBnbG9iYWwgJiYgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jYXRpb24gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsIi8vIFRoZSByZWdlbmVyYXRvciBydW50aW1lIGlzIG5lZWRlZCBzaW5jZSB0aGUgdGVzdCB1c2UgZnVuY3Rpb25zXG4vLyB3aXRoIHRoZSBhc3luYy9hd2FpdCBrZXl3b3Jkcy4gU2VlXG4vLyBodHRwczovL2JhYmVsanMuaW8vZG9jcy9lbi9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLXJlZ2VuZXJhdG9yXG5pbXBvcnQgXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIjtcbi8vIFBvbHlmaWxsIGBQcm9taXNlYCBmb3IgSW50ZXJuZXQgRXhwbG9yZXIuXG5pbXBvcnQgXCJlczYtcHJvbWlzZS9hdXRvXCI7XG5cbi8vIFRoaXMgaXMgYSBmdW4gcGllY2Ugb2YgY29kZS4gTGV0IG1lIHRlbGwgeW91IHRoZSBzdG9yeSBiZWhpbmQgaXQ6XG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBhbmQgMTEgaGF2ZSBhIGJ1ZyB3aGVyZSB0aGUgZXZlbnQgaGFuZGxlcnNcbi8vIGZvciBYTUxIdHRwUmVxdWVzdHMgd2lsbCBiZSBpbnZva2VkIHdpdGggYSBzaWduaWZpY2FudCBkZWxheSBhZnRlclxuLy8gdGhlIGFjdHVhbCByZXF1ZXN0IGhhcyBiZWVuIGZpbmlzaGVkLiBTbywgZXZlbiBpZiB0aGUgSFRUUCByZXF1ZXN0XG4vLyBvbmx5IHRvb2sgMXMgdG8gY29tcGxldGUsIElFIHdpbGwgd2FpdCBhbm90aGVyIDIwcyBiZWZvcmUgaXQgZGVjaWRlc1xuLy8gdG8gdGVsbCB5b3VyIGFwcGxpY2F0aW9uIHRoYXQgdGhlIHJlcXVlc3QgaGFzIGJlZW4gZmluaXNoZWQuIFRoaXNcbi8vIHdhcyBub3QgYSBiaWcgcHJvYmxlbSBpbiBkYWlseSB1c2Ugc2luY2UgdGhpcyBpc3N1ZSBkaWQgb25seSBvY2N1clxuLy8gd2hlbiB0aGUgdXNlciBkaWQgbm90IGludGVyYWN0IHdpdGggdGhlIHdlYnBhZ2UsIGUuZy4gbW92ZSB0aGUgbW91c2UuXG4vLyBIb3dldmVyLCB3aGVuIHRlc3RpbmcgaW4gYXV0b21hdGVkIGJyb3dzc2Vycywgbm8gdXNlciBpbnRlcmFjdGlvbiB3YXNcbi8vIG9jY3VycmluZy5cbi8vIEV2ZW50dWFsbHksIHNvbWVvbmUgZmlndXJlZCBvdXQgdGhhdCB0aGlzIHdhcyByZWxhdGVkIHRvIGEgUHJvbWlzZVxuLy8gcG9seWZpbGwgdGhhdCBpcyB1c2VkIGJ5IHRoZSBheGlvcyBIVFRQIGNsaWVudC4gVGhpcyBzb2x1dGlvbiBpc1xuLy8gdG8gdXNlIGEgdGltZW91dCwgYXMgZm9sbG93cywgd2hpY2ggaXMgZW5vdWdoIHRvIGNhdXNlIHRoZSBuZXR3b3JrXG4vLyBkZWxheXMgdG8gdmFuaXNoLlxuLy8gV2hvZXZlciBmb3VuZCB0aGF0IHBhdGNoLCBJIGhvcGUgdGhleSB3aWxsIGdvIHRvIGhlYXZlbi5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzE4NjJcbmZ1bmN0aW9uIHQoKSB7XG4gIHdpbmRvdy5zZXRUaW1lb3V0KHQsIDEwKTtcbn1cbnQoKTtcblxuYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gIC8vIENsZWFyIGxvY2FsU3RvcmFnZSBiZWZvcmUgZXZlcnkgdGVzdCB0byBwcmV2ZW50IHN0b3JlZCBVUkxzIHRvXG4gIC8vIGludGVyZmVyZSB3aXRoIG91ciBzZXR1cC5cbiAgbG9jYWxTdG9yYWdlLmNsZWFyKCk7XG59KTtcblxucmVxdWlyZShcIi4vaGVscGVycy9wdXBwZXRlZXIvcmVwb3J0ZXIuanNcIik7XG5yZXF1aXJlKFwiLi90ZXN0LWNvbW1vbi5qc1wiKTtcbnJlcXVpcmUoXCIuL3Rlc3QtYnJvd3Nlci1zcGVjaWZpYy5qc1wiKTtcbnJlcXVpcmUoXCIuL3Rlc3QtcGFyYWxsZWwtdXBsb2Fkcy5qc1wiKTtcbnJlcXVpcmUoXCIuL3Rlc3QtdGVybWluYXRlLmpzXCIpO1xucmVxdWlyZShcIi4vdGVzdC1lbmQtdG8tZW5kLmpzXCIpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhc3luYyBmdW5jdGlvbiBhc3NlcnRVcmxTdG9yYWdlKHVybFN0b3JhZ2UpIHtcbiAgLy8gSW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGVzdCwgdGhlIHN0b3JhZ2Ugc2hvdWxkIGJlIGVtcHR5LlxuICBsZXQgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpO1xuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcblxuICAvLyBBZGQgYSBmZXcgdXBsb2FkcyBpbnRvIHRoZSBzdG9yYWdlXG4gIGNvbnN0IGtleTEgPSBhd2FpdCB1cmxTdG9yYWdlLmFkZFVwbG9hZChcImZpbmdlcnByaW50QVwiLCB7IGlkOiAxIH0pO1xuICBjb25zdCBrZXkyID0gYXdhaXQgdXJsU3RvcmFnZS5hZGRVcGxvYWQoXCJmaW5nZXJwcmludEFcIiwgeyBpZDogMiB9KTtcbiAgY29uc3Qga2V5MyA9IGF3YWl0IHVybFN0b3JhZ2UuYWRkVXBsb2FkKFwiZmluZ2VycHJpbnRCXCIsIHsgaWQ6IDMgfSk7XG5cbiAgZXhwZWN0KC9edHVzOjpmaW5nZXJwcmludEE6Oi8udGVzdChrZXkxKSkudG9CZSh0cnVlKTtcbiAgZXhwZWN0KC9edHVzOjpmaW5nZXJwcmludEE6Oi8udGVzdChrZXkyKSkudG9CZSh0cnVlKTtcbiAgZXhwZWN0KC9edHVzOjpmaW5nZXJwcmludEI6Oi8udGVzdChrZXkzKSkudG9CZSh0cnVlKTtcblxuICAvLyBRdWVyeSB0aGUganVzdCBzdG9yZWQgdXBsb2FkcyBpbmRpdmlkdWFsbHlcbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoXCJmaW5nZXJwcmludEFcIik7XG4gIHNvcnQocmVzdWx0KTtcbiAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXG4gICAgeyBpZDogMSwgdXJsU3RvcmFnZUtleToga2V5MSB9LFxuICAgIHsgaWQ6IDIsIHVybFN0b3JhZ2VLZXk6IGtleTIgfVxuICBdKTtcblxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChcImZpbmdlcnByaW50QlwiKTtcbiAgc29ydChyZXN1bHQpO1xuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAzLCB1cmxTdG9yYWdlS2V5OiBrZXkzIH1cbiAgXSk7XG5cbiAgLy8gQ2hlY2sgdGhhdCB3ZSBjYW4gcmV0cmlldmUgYWxsIHN0b3JlZCB1cGxvYWRzXG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZEFsbFVwbG9hZHMoKTtcbiAgc29ydChyZXN1bHQpO1xuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gICAgeyBpZDogMiwgdXJsU3RvcmFnZUtleToga2V5MiB9LFxuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfVxuICBdKTtcblxuICAvLyBDaGVjayB0aGF0IGl0IGNhbiByZW1vdmUgYW4gdXBsb2FkIGFuZCB3aWxsIG5vdCByZXR1cm4gaXQgYmFja1xuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkyKTtcbiAgYXdhaXQgdXJsU3RvcmFnZS5yZW1vdmVVcGxvYWQoa2V5Myk7XG5cbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoXCJmaW5nZXJwcmludEFcIik7XG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1xuICAgIHsgaWQ6IDEsIHVybFN0b3JhZ2VLZXk6IGtleTEgfVxuICBdKTtcblxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChcImZpbmdlcnByaW50QlwiKTtcbiAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG59O1xuXG4vLyBTb3J0IHRoZSByZXN1bHRzIGZyb20gdGhlIFVSTCBzdG9yYWdlIHNpbmNlIHRoZSBvcmRlciBpbiBub3QgZGV0ZXJtaW5pc3RpYy5cbmZ1bmN0aW9uIHNvcnQocmVzdWx0KSB7XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG59XG4iLCIvKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiAwICovXG5cbnZhciB0ZXN0c0NvbXBsZXRlZCA9IGZhbHNlO1xudmFyIHRlc3RzUGFzc2VkID0gdHJ1ZTtcblxuLy8gVGhpcyByZXBvcnRlciBpcyB1c2VkIGJ5IGJpbi9wdXBwZXRlZXItamFzbWluZS5qcyB0byBvYnRhaW4gdGhlIHRlc3QgcmVzdWx0cy5cbi8vIFNlZSBodHRwczovL2phc21pbmUuZ2l0aHViLmlvL2FwaS9lZGdlL1JlcG9ydGVyLmh0bWwgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGVcbi8vIGZ1bmN0aW9uIHNpZ25hdHVyZXMuXG52YXIgcmVwb3J0ZXIgPSB7XG4gIGphc21pbmVTdGFydGVkOiBmdW5jdGlvbiAoc3VpdGVJbmZvKSB7IH0sXG4gIHN1aXRlU3RhcnRlZDogZnVuY3Rpb24gKHJlc3VsdCkgeyB9LFxuICBzcGVjU3RhcnRlZDogZnVuY3Rpb24gKHJlc3VsdCkgeyB9LFxuICBzcGVjRG9uZTogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIC8vIFByaW50IHRoZSB0ZXN0IHJlc3VsdCB0byB0aGUgY29uc29sZS5cbiAgICB2YXIgcGFzc2VkID0gcmVzdWx0LnN0YXR1cyA9PT0gXCJwYXNzZWRcIjtcbiAgICB2YXIgcHJlZml4ID0gcGFzc2VkID8gXCLinJNcIiA6IFwi4pyYXCI7XG4gICAgY29uc29sZS5sb2cocHJlZml4LCByZXN1bHQuZnVsbE5hbWUpO1xuXG4gICAgdGVzdHNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIHRlc3RzUGFzc2VkID0gdGVzdHNQYXNzZWQgJiYgcGFzc2VkO1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmFpbHVyZTogXCIgKyByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zW2ldLm1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5sb2cocmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9uc1tpXS5zdGFjayk7XG4gICAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICB9XG5cbiAgfSxcbiAgc3VpdGVEb25lOiBmdW5jdGlvbiAocmVzdWx0KSB7IH0sXG4gIGphc21pbmVEb25lOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIHN1Y2Nlc3MgPSB0ZXN0c0NvbXBsZXRlZCAmJiB0ZXN0c1Bhc3NlZDtcblxuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlRlc3RzIHBhc3NlZCFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVGVzdHMgZmFpbGVkIVwiKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgX19qYXNtaW5lQ2FsbGJhY2sgZnVuY3Rpb24gaXMgZXhwb3NlZCBieSB0aGUgYmluL3B1cHBldGVlci1qYXNtaW5lLmpzXG4gICAgLy8gc2NyaXB0LiBTZWUgaXQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5fX2phc21pbmVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3aW5kb3cuX19qYXNtaW5lQ2FsbGJhY2soc3VjY2Vzcyk7XG4gICAgfVxuICB9XG59O1xuXG53aW5kb3cuamFzbWluZS5nZXRFbnYoKS5hZGRSZXBvcnRlcihyZXBvcnRlcik7XG4iLCJjb25zdCBpc0Jyb3dzZXIgID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IGlzTm9kZSAgICAgPSAhaXNCcm93c2VyO1xuXG4vKipcbiAqIE9idGFpbiBhIHBsYXRmb3JtIHNwZWNpZmljIGJ1ZmZlciBvYmplY3QsIHdoaWNoIGNhbiBiZVxuICogaGFuZGxlZCBieSB0dXMtanMtY2xpZW50LlxuICovXG5mdW5jdGlvbiBnZXRCbG9iKHN0cikge1xuICBpZiAoaXNOb2RlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBCbG9iKHN0ci5zcGxpdChcIlwiKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9taXNlIGFuZCBvYnRhaW4gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9uc1xuICogb3V0c2lkZSBvZiB0aGUgUHJvbWlzZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZmxhdFByb21pc2UoKSB7XG4gIGxldCByZXNvbHZlRm47XG4gIGxldCByZWplY3RGbjtcbiAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICByZXNvbHZlRm4gPSByZXNvbHZlO1xuICAgIHJlamVjdEZuID0gcmVqZWN0O1xuICB9KTtcblxuICByZXR1cm4gWyBwLCByZXNvbHZlRm4sIHJlamVjdEZuIF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3B5LWFibGUgZnVuY3Rpb24gd2hpY2ggcmVzb2x2ZXMgYSBQcm9taXNlXG4gKiBvbmNlIGl0IGlzIGNhbGxlZC5cbiAqL1xuZnVuY3Rpb24gd2FpdGFibGVGdW5jdGlvbihuYW1lID0gXCJmdW5jXCIpIHtcbiAgY29uc3QgWyBwcm9taXNlLCByZXNvbHZlIF0gPSBmbGF0UHJvbWlzZSgpO1xuICBjb25zdCBmbiA9IGphc21pbmUuY3JlYXRlU3B5KG5hbWUsIHJlc29sdmUpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gIGZuLnRvQmVDYWxsZWQgPSBwcm9taXNlO1xuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5LCBcInRpbWVkIG91dFwiKSk7XG59XG5cbi8qKlxuICogVGVzdEh0dHBTdGFjayBpbXBsZW1lbnRzIHRoZSBIVFRQIHN0YWNrIGludGVyZmFjZSBmb3IgdHVzLWpzLWNsaWVudFxuICogYW5kIGNhbiBiZSB1c2VkIHRvIGFzc2VydCBvdXRnb2luZyByZXF1ZXN0cyBhbmQgcmVzcG9uZCB3aXRoIG1vY2sgZGF0YS5cbiAqL1xuY2xhc3MgVGVzdEh0dHBTdGFjayB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3BlbmRpbmdXYWl0cyA9IFtdO1xuICB9XG5cbiAgY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgIHJldHVybiBuZXcgVGVzdFJlcXVlc3QobWV0aG9kLCB1cmwsIChyZXEpID0+IHtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nV2FpdHMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3BlbmRpbmdXYWl0cy5zaGlmdCgpO1xuICAgICAgICBoYW5kbGVyKHJlcSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzLnB1c2gocmVxKTtcbiAgICB9KTtcbiAgfVxuXG4gIG5leHRSZXF1ZXN0KCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nUmVxdWVzdHMubGVuZ3RoID49IDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcGVuZGluZ1JlcXVlc3RzLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcGVuZGluZ1dhaXRzLnB1c2gocmVzb2x2ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgVGVzdFJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihtZXRob2QsIHVybCwgb25SZXF1ZXN0U2VuZCkge1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fTtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuXG4gICAgdGhpcy5fb25SZXF1ZXN0U2VuZCA9IG9uUmVxdWVzdFNlbmQ7XG4gICAgdGhpcy5fb25Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgWyB0aGlzLl9yZXF1ZXN0UHJvbWlzZSwgdGhpcy5fcmVzb2x2ZVJlcXVlc3QsIHRoaXMuX3JlamVjdFJlcXVlc3QgXSA9IGZsYXRQcm9taXNlKCk7XG4gIH1cblxuICBnZXRNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kO1xuICB9XG5cbiAgZ2V0VVJMKCkge1xuICAgIHJldHVybiB0aGlzLnVybDtcbiAgfVxuXG4gIHNldEhlYWRlcihoZWFkZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gIH1cblxuICBnZXRIZWFkZXIoaGVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSB8fCBudWxsO1xuICB9XG5cbiAgc2V0UHJvZ3Jlc3NIYW5kbGVyKHByb2dyZXNzSGFuZGxlcikge1xuICAgIHRoaXMuX29uUHJvZ3Jlc3MgPSBwcm9ncmVzc0hhbmRsZXI7XG4gIH1cblxuICBzZW5kKGJvZHkgPSBudWxsKSB7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKDApO1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyhib2R5Lmxlbmd0aCB8fCBib2R5LnNpemUgfHwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb25SZXF1ZXN0U2VuZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFByb21pc2U7XG4gIH1cblxuICBhYm9ydCgpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KG5ldyBFcnJvcihcInJlcXVlc3QgYWJvcnRlZFwiKSk7XG4gIH1cblxuICBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuXG4gIHJlc3BvbmRXaXRoKHJlc0RhdGEpIHtcbiAgICByZXNEYXRhLnJlc3BvbnNlSGVhZGVycyA9IHJlc0RhdGEucmVzcG9uc2VIZWFkZXJzIHx8IHt9O1xuXG4gICAgY29uc3QgcmVzID0gbmV3IFRlc3RSZXNwb25zZShyZXNEYXRhKTtcbiAgICB0aGlzLl9yZXNvbHZlUmVxdWVzdChyZXMpO1xuICB9XG5cbiAgcmVzcG9uc2VFcnJvcihlcnIpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KGVycik7XG4gIH1cbn1cblxuY2xhc3MgVGVzdFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSByZXM7XG4gIH1cbiAgZ2V0U3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5zdGF0dXM7XG4gIH1cblxuXG4gIGdldEhlYWRlcihoZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl07XG4gIH1cblxuICBnZXRCb2R5KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5yZXNwb25zZVRleHQ7XG4gIH1cblxuICBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGVzdEh0dHBTdGFjayxcbiAgd2FpdGFibGVGdW5jdGlvbixcbiAgd2FpdCxcbiAgZ2V0QmxvYlxufTtcbiIsIi8qIGdsb2JhbCBCbG9iICAqL1xuXG5jb25zdCBhc3NlcnRVcmxTdG9yYWdlID0gcmVxdWlyZShcIi4vaGVscGVycy9hc3NlcnRVcmxTdG9yYWdlXCIpO1xuY29uc3QgeyBUZXN0SHR0cFN0YWNrLCB3YWl0YWJsZUZ1bmN0aW9uLCB3YWl0IH0gPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxzXCIpO1xuY29uc3QgdHVzID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcblxuZGVzY3JpYmUoXCJ0dXNcIiwgZnVuY3Rpb24gKCkge1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCIjVXBsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpdChcInNob3VsZCByZXN1bWUgYW4gdXBsb2FkIGZyb20gYSBzdG9yZWQgdXJsXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidHVzOjpmaW5nZXJwcmludGVkOjoxMzM3XCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdXBsb2FkVXJsOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZ1wiXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IG5ldyBCbG9iKFwiaGVsbG8gd29ybGRcIi5zcGxpdChcIlwiKSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZmluZ2VycHJpbnQ6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJmaW5nZXJwcmludFwiKS5hbmQucmVzb2x2ZVRvKFwiZmluZ2VycHJpbnRlZFwiKTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBwcmV2aW91c1VwbG9hZHMgPSBhd2FpdCB1cGxvYWQuZmluZFByZXZpb3VzVXBsb2FkcygpO1xuICAgICAgZXhwZWN0KHByZXZpb3VzVXBsb2FkcykudG9FcXVhbChbe1xuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIsXG4gICAgICAgIHVybFN0b3JhZ2VLZXk6IFwidHVzOjpmaW5nZXJwcmludGVkOjoxMzM3XCJcbiAgICAgIH1dKTtcbiAgICAgIHVwbG9hZC5yZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQocHJldmlvdXNVcGxvYWRzWzBdKTtcblxuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmaWxlLCB1cGxvYWQub3B0aW9ucyk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogM1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMyk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExIC0gMyk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwic3RvcmluZyBvZiB1cGxvYWQgdXJsc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgZmluZ2VycHJpbnQ6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuXG4gICAgICB2YXIgc3RhcnRVcGxvYWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlID0gbmV3IEJsb2IoXCJoZWxsbyB3b3JsZFwiLnNwbGl0KFwiXCIpKTtcbiAgICAgICAgc3B5T24ob3B0aW9ucywgXCJmaW5nZXJwcmludFwiKS5hbmQucmVzb2x2ZVRvKFwiZmluZ2VycHJpbnRlZFwiKTtcbiAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MgPSB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpO1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiBcIi91cGxvYWRzL2JsYXJnaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgZGVsYXkgdG8gYWxsb3cgdGhlIFByb21pc2VzIHRvIHNldHRsZVxuICAgICAgICBhd2FpdCB3YWl0KDEwKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmaW5pc2hVcGxvYWQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICB9O1xuXG4gICAgICBpdChcInNob3VsZCBzdG9yZSBhbmQgcmV0YWluIHdpdGggZGVmYXVsdCBvcHRpb25zXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBhd2FpdCBzdGFydFVwbG9hZCgpO1xuXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoMCk7XG4gICAgICAgIGV4cGVjdChrZXkuaW5kZXhPZihcInR1czo6ZmluZ2VycHJpbnRlZDo6XCIpKS50b0JlKDApO1xuXG4gICAgICAgIGNvbnN0IHN0b3JlZFVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgICAgIGV4cGVjdChzdG9yZWRVcGxvYWQudXBsb2FkVXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC5zaXplKS50b0JlKDExKTtcblxuICAgICAgICBhd2FpdCBmaW5pc2hVcGxvYWQoKTtcblxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShKU09OLnN0cmluZ2lmeShzdG9yZWRVcGxvYWQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCBzdG9yZSBhbmQgcmVtb3ZlIHdpdGggb3B0aW9uIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzIHNldFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9wdGlvbnMucmVtb3ZlRmluZ2VycHJpbnRPblN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBhd2FpdCBzdGFydFVwbG9hZCgpO1xuXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoMCk7XG4gICAgICAgIGV4cGVjdChrZXkuaW5kZXhPZihcInR1czo6ZmluZ2VycHJpbnRlZDo6XCIpKS50b0JlKDApO1xuXG4gICAgICAgIGNvbnN0IHN0b3JlZFVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgICAgIGV4cGVjdChzdG9yZWRVcGxvYWQudXBsb2FkVXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC5zaXplKS50b0JlKDExKTtcblxuICAgICAgICBhd2FpdCBmaW5pc2hVcGxvYWQoKTtcbiAgICAgICAgZXhwZWN0KGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpLnRvQmUobnVsbCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGRlbGV0ZSB1cGxvYWQgdXJscyBvbiBhIDRYWFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBuZXcgQmxvYihcImhlbGxvIHdvcmxkXCIuc3BsaXQoXCJcIikpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgZmluZ2VycHJpbnQ6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJmaW5nZXJwcmludFwiKS5hbmQucmVzb2x2ZVRvKFwiZmluZ2VycHJpbnRlZFwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuXG4gICAgICB1cGxvYWQucmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkKHtcbiAgICAgICAgdXBsb2FkVXJsOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZ1wiLFxuICAgICAgICB1cmxTdG9yYWdlS2V5OiBcInR1czo6ZmluZ2VycHJpbnRlZDo6MTMzN1wiXG4gICAgICB9KTtcblxuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQwMFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXQoMTApO1xuXG4gICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzdcIikpLnRvQmUobnVsbCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcInVwbG9hZGluZyBkYXRhIGZyb20gYSBSZWFkZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gbWFrZVJlYWRlcihjb250ZW50LCByZWFkU2l6ZSA9IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHtcbiAgICAgICAgICB2YWx1ZTogY29udGVudC5zcGxpdChcIlwiKSxcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLnNsaWNlKDAscmVhZFNpemUpO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zbGljZShyZWFkU2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdmFsdWUsIGRvbmU6IGRvbmUgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6IHdhaXRhYmxlRnVuY3Rpb24oXCJjYW5jZWxcIilcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVhZGVyO1xuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBhc3NlcnRSZWFkZXJVcGxvYWQoeyByZWFkU2l6ZSwgY2h1bmtTaXplIH0pIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG1ha2VSZWFkZXIoXCJoZWxsbyB3b3JsZFwiLCByZWFkU2l6ZSk7XG5cbiAgICAgICAgdmFyIHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICAgIGNodW5rU2l6ZTogY2h1bmtTaXplLFxuICAgICAgICAgIG9uUHJvZ3Jlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblByb2dyZXNzXCIpLFxuICAgICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKSxcbiAgICAgICAgICBmaW5nZXJwcmludDogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgc3B5T24ob3B0aW9ucywgXCJmaW5nZXJwcmludFwiKS5hbmQucmVzb2x2ZVRvKFwiZmluZ2VycHJpbnRlZFwiKTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHJlYWRlciwgdXBsb2FkLm9wdGlvbnMpO1xuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUodW5kZWZpbmVkKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1EZWZlci1MZW5ndGhcIl0pLnRvQmUoMSk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgICBleHBlY3QocmVxLmJvZHkubGVuZ3RoKS50b0JlKDExKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uUHJvZ3Jlc3MudG9CZUNhbGxlZDtcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIG51bGwpO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDExKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5KS50b0JlKG51bGwpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICAgIH1cblxuICAgICAgaXQoXCJzaG91bGQgdXBsb2FkIGRhdGFcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBhd2FpdCBhc3NlcnRSZWFkZXJVcGxvYWQoeyBjaHVua1NpemU6IDEwMCwgcmVhZFNpemU6IDEwMCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCByZWFkIG11bHRpcGxlIHRpbWVzIGZyb20gdGhlIHJlYWRlclwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF3YWl0IGFzc2VydFJlYWRlclVwbG9hZCh7IGNodW5rU2l6ZTogMTAwLCByZWFkU2l6ZTogNiB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCB1c2UgbXVsdGlwbGUgUEFUQ0ggcmVxdWVzdHNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcihcImhlbGxvIHdvcmxkXCIsIDEpO1xuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgICBjaHVua1NpemU6IDYsXG4gICAgICAgICAgb25Qcm9ncmVzczogd2FpdGFibGVGdW5jdGlvbihcIm9uUHJvZ3Jlc3NcIiksXG4gICAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpLFxuICAgICAgICAgIGZpbmdlcnByaW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBzcHlPbihvcHRpb25zLCBcImZpbmdlcnByaW50XCIpLmFuZC5yZXNvbHZlVG8oXCJmaW5nZXJwcmludGVkXCIpO1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocmVhZGVyLCB1cGxvYWQub3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSh1bmRlZmluZWQpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLURlZmVyLUxlbmd0aFwiXSkudG9CZSgxKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5sZW5ndGgpLnRvQmUoNik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uUHJvZ3Jlc3MudG9CZUNhbGxlZDtcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNiwgbnVsbCk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoNik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgICBleHBlY3QocmVxLmJvZHkubGVuZ3RoKS50b0JlKDUpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDExKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5ib2R5KS50b0JlKG51bGwpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInNob3VsZCByZXRyeSB0aGUgUE9TVCByZXF1ZXN0XCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG1ha2VSZWFkZXIoXCJoZWxsbyB3b3JsZFwiLCAxKTtcblxuICAgICAgICB2YXIgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgICBjaHVua1NpemU6IDExLFxuICAgICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwLCAxMF0sXG4gICAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpLFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJzaG91bGQgcmV0cnkgdGhlIGZpcnN0IFBBVENIIHJlcXVlc3RcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVhZGVyID0gbWFrZVJlYWRlcihcImhlbGxvIHdvcmxkXCIsIDEpO1xuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICAgIGNodW5rU2l6ZTogMTEsXG4gICAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIiksXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDExKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwic2hvdWxkIHJldHJ5IGZvbGxvd2luZyBQQVRDSCByZXF1ZXN0c1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBtYWtlUmVhZGVyKFwiaGVsbG8gd29ybGQgdGhlcmUhXCIpO1xuXG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICAgIGNodW5rU2l6ZTogNixcbiAgICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQocmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogNTAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDEyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDE4XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTgpO1xuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMThcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJzaG91bGQgY2FuY2VsIHRoZSByZWFkZXIgd2hlbiBhYm9ydGVkXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG1ha2VSZWFkZXIoXCJoZWxsbyB0aGVyZSB3b3JsZFwiKTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IG5ldyBUZXN0SHR0cFN0YWNrKCksXG4gICAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgICBjaHVua1NpemU6IDYsXG4gICAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICAgIC8vIFdlIHdhaXQgdW50aWwgdGhlIGZpcnN0IHJlcXVlc3QgYXJyaXZlcywgc28gdGhhdCB0aGUgZmlyc3QgcHJvbWlzZXMgaGF2ZSByZXNvbHZlZC5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5odHRwU3RhY2submV4dFJlcXVlc3QoKTtcblxuICAgICAgICB1cGxvYWQuYWJvcnQoKTtcblxuICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsLnRvQmVDYWxsZWQ7XG4gICAgICAgIGV4cGVjdChyZWFkZXIuY2FuY2VsKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwicmVzb2x2aW5nIG9mIFVSSXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRGlzYWJsZSB0aGVzZSB0ZXN0cyBmb3IgSUUgMTAgYW5kIDExIGJlY2F1c2UgaXQncyBub3QgcG9zc2libGUgdG8gb3ZlcndyaXRlXG4gICAgICAvLyB0aGUgbmF2aWdhdG9yLnByb2R1Y3QgcHJvcGVydHkuXG4gICAgICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnQvXCIpID4gMDtcbiAgICAgIGlmIChpc0lFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgdGVzdHMgZm9yIFJlYWN0IE5hdGl2ZSBpbiBJbnRlcm5ldCBFeHBsb3JlclwiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9yaWdpbmFsUHJvZHVjdCA9IG5hdmlnYXRvci5wcm9kdWN0O1xuXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgamFzbWluZS5BamF4Lmluc3RhbGwoKTtcbiAgICAgICAgLy8gU2ltdWxhdGUgUmVhY3QgTmF0aXZlIGVudmlyb25tZW50IHRvIGVuYWJsZSBVUklzIGFzIGlucHV0IG9iamVjdHMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXZpZ2F0b3IsIFwicHJvZHVjdFwiLCB7XG4gICAgICAgICAgdmFsdWU6IFwiUmVhY3ROYXRpdmVcIixcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgamFzbWluZS5BamF4LnVuaW5zdGFsbCgpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCBcInByb2R1Y3RcIiwge1xuICAgICAgICAgIHZhbHVlOiBvcmlnaW5hbFByb2R1Y3QsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwic2hvdWxkIHVwbG9hZCBhIGZpbGUgZnJvbSBhbiBVUklcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlsZSA9IHtcbiAgICAgICAgICB1cmk6IFwiZmlsZTovLy9teS9maWxlLmRhdFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIilcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICAgIC8vIFdhaXQgYSBzaG9ydCBpbnRlcnZhbCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgWEhSIGhhcyBiZWVuIHNlbnQuXG4gICAgICAgIGF3YWl0IHdhaXQoMCk7XG5cbiAgICAgICAgdmFyIHJlcSA9IGphc21pbmUuQWpheC5yZXF1ZXN0cy5tb3N0UmVjZW50KCk7XG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiZmlsZTovLy9teS9maWxlLmRhdFwiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJHRVRcIik7XG4gICAgICAgIGV4cGVjdChyZXEucmVzcG9uc2VUeXBlKS50b0JlKFwiYmxvYlwiKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExLFxuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3BvbnNlOiBuZXcgQmxvYihcImhlbGxvIHdvcmxkXCIuc3BsaXQoXCJcIikpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxMSk7XG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiBcIi91cGxvYWRzL2JsYXJnaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExKTtcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJzaG91bGQgZW1pdCBhbiBlcnJvciBpZiBpdCBjYW4ndCByZXNvbHZlIHRoZSBVUklcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmlsZSA9IHtcbiAgICAgICAgICB1cmk6IFwiZmlsZTovLy9teS9maWxlLmRhdFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICAgIG9uRXJyb3I6IHdhaXRhYmxlRnVuY3Rpb24oXCJvbkVycm9yXCIpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIFhIUiBoYXMgYmVlbiBzZW50LlxuICAgICAgICBhd2FpdCB3YWl0KDApO1xuXG4gICAgICAgIHZhciByZXEgPSBqYXNtaW5lLkFqYXgucmVxdWVzdHMubW9zdFJlY2VudCgpO1xuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImZpbGU6Ly8vbXkvZmlsZS5kYXRcIik7XG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiR0VUXCIpO1xuICAgICAgICBleHBlY3QocmVxLnJlc3BvbnNlVHlwZSkudG9CZShcImJsb2JcIik7XG5cbiAgICAgICAgcmVxLnJlc3BvbnNlRXJyb3IoKTtcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZDtcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgZmV0Y2ggYGZpbGUudXJpYCBhcyBCbG9iLCBtYWtlIHN1cmUgdGhlIHVyaSBpcyBjb3JyZWN0IGFuZCBhY2Nlc3NpYmxlLiBbb2JqZWN0IE9iamVjdF1cIikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiI0xvY2FsU3RvcmFnZVVybFN0b3JhZ2VcIiwgZnVuY3Rpb24gKCkge1xuICAgIGl0KFwic2hvdWxkIGFsbG93IHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgdXBsb2Fkc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBhd2FpdCBhc3NlcnRVcmxTdG9yYWdlKHR1cy5kZWZhdWx0T3B0aW9ucy51cmxTdG9yYWdlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgd2FpdCwgZ2V0QmxvYiB9ID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsc1wiKTtcbmNvbnN0IHR1cyA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5cbi8vIFVuY29tbWVudCB0byBlbmFibGUgZGVidWcgbG9nIGZyb20gdHVzLWpzLWNsaWVudFxuLy90dXMuZW5hYmxlRGVidWdMb2coKTtcblxuZGVzY3JpYmUoXCJ0dXNcIiwgZnVuY3Rpb24gKCkge1xuICBkZXNjcmliZShcIiNpc1N1cHBvcnRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoXCJzaG91bGQgYmUgdHJ1ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBleHBlY3QodHVzLmlzU3VwcG9ydGVkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIiNVcGxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgIGl0KFwic2hvdWxkIHRocm93IGlmIG5vIGVycm9yIGhhbmRsZXIgaXMgYXZhaWxhYmxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChudWxsKTtcbiAgICAgIGV4cGVjdCh1cGxvYWQuc3RhcnQuYmluZCh1cGxvYWQpKS50b1Rocm93RXJyb3IoXCJ0dXM6IG5vIGZpbGUgb3Igc3RyZWFtIHRvIHVwbG9hZCBwcm92aWRlZFwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHRocm93IGlmIG5vIGVuZHBvaW50IGFuZCB1cGxvYWQgVVJMIGlzIHByb3ZpZGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUpO1xuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcihcInR1czogbmVpdGhlciBhbiBlbmRwb2ludCBvciBhbiB1cGxvYWQgVVJMIGlzIHByb3ZpZGVkXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgdXBsb2FkIGEgZmlsZVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBDdXN0b206IFwiYmxhcmdoXCJcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBmb286IFwiaGVsbG9cIixcbiAgICAgICAgICBiYXI6IFwid29ybGRcIixcbiAgICAgICAgICBub25sYXRpbjogXCJzxYJvxYRjZVwiLFxuICAgICAgICAgIG51bWJlcjogMTAwXG4gICAgICAgIH0sXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbigpXG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvblByb2dyZXNzXCIpO1xuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG5cbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDExKTtcbiAgICAgIC8vaWYgKGlzQnJvd3NlcikgZXhwZWN0KHJlcS53aXRoQ3JlZGVudGlhbHMpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU1ldGFkYXRhXCJdKS50b0JlKFwiZm9vIGFHVnNiRzg9LGJhciBkMjl5YkdRPSxub25sYXRpbiBjOFdDYjhXRVkyVT0sbnVtYmVyIE1UQXdcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZShcImJsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEpO1xuICAgICAgLy9pZiAoaXNCcm93c2VyKSBleHBlY3QocmVxLndpdGhDcmVkZW50aWFscykudG9CZSh0cnVlKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjcmVhdGUgYW4gdXBsb2FkIGlmIHJlc3VtaW5nIGZhaWxzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCJcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDRcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDExKTtcblxuICAgICAgLy8gVGhlIHVwbG9hZCBVUkwgc2hvdWxkIGJlIGNsZWFyZWQgd2hlbiB0dXMtanMuY2xpZW50IHRyaWVzIHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWQuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShudWxsKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNyZWF0ZSBhbiB1cGxvYWQgdXNpbmcgdGhlIGNyZWF0aW9uLXdpdGgtZGF0YSBleHRlbnNpb25cIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiB0cnVlLFxuICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpXG4gICAgICB9O1xuXG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uQ2h1bmtDb21wbGV0ZVwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoMTEpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIsXG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjcmVhdGUgYW4gdXBsb2FkIHdpdGggcGFydGlhbCBkYXRhIGFuZCBjb250aW51ZVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICB1cGxvYWREYXRhRHVyaW5nQ3JlYXRpb246IHRydWUsXG4gICAgICAgIGNodW5rU2l6ZTogNixcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvblByb2dyZXNzXCIpO1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkNodW5rQ29tcGxldGVcIik7XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgxMSk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiLFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcblxuICAgICAgLy8gT25jZSB0aGUgc2Vjb25kIHJlcXVlc3QgaGFzIGJlZW4gc2VudCwgdGhlIHByb2dyZXNzIGhhbmRsZXIgbXVzdCBoYXZlIGJlZW4gaW52b2tlZC5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDYsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNiwgNiwgMTEpO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDYpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2hcIixcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExLCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGFkZCB0aGUgcmVxdWVzdCdzIGJvZHkgYW5kIElEIHRvIGVycm9yc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBhZGRSZXF1ZXN0SWQ6IHRydWUsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHZhciByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICBjb25zdCByZXFJZCA9IHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlgtUmVxdWVzdC1JRFwiXTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVxSWQpLnRvQmUoXCJzdHJpbmdcIik7XG4gICAgICBleHBlY3QocmVxSWQubGVuZ3RoKS50b0JlKDM2KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIHJlc3BvbnNlVGV4dDogXCJzZXJ2ZXJfZXJyb3JcIlxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoXCJ0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogNTAwLCByZXNwb25zZSB0ZXh0OiBzZXJ2ZXJfZXJyb3IsIHJlcXVlc3QgaWQ6IFwiICsgcmVxSWQgKyBcIilcIik7XG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVxdWVzdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXNwb25zZSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGludm9rZSB0aGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgY2FsbGJhY2tzXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgdXBsb2FkVXJsOiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb29cIixcbiAgICAgICAgb25CZWZvcmVSZXF1ZXN0OiBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRVUkwoKSkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb29cIik7XG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZShcIkhFQURcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWZ0ZXJSZXNwb25zZTogZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRVUkwoKSkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb29cIik7XG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZShcIkhFQURcIik7XG4gICAgICAgICAgZXhwZWN0KHJlcy5nZXRTdGF0dXMoKSkudG9CZSgyMDQpO1xuICAgICAgICAgIGV4cGVjdChyZXMuZ2V0SGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSkudG9CZSgxMSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25CZWZvcmVSZXF1ZXN0XCIpO1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkFmdGVyUmVzcG9uc2VcIik7XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTEsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25CZWZvcmVSZXF1ZXN0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHJlc3VtaW5nIGZhaWxzIGFuZCBubyBlbmRwb2ludCBpcyBwcm92aWRlZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVwbG9hZFVybDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmdcIixcbiAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIilcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA0XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWQ7XG4gICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoXCJ0dXM6IHVuYWJsZSB0byByZXN1bWUgdXBsb2FkIChuZXcgdXBsb2FkIGNhbm5vdCBiZSBjcmVhdGVkIHdpdGhvdXQgYW4gZW5kcG9pbnQpLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBIRUFELCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZywgcmVzcG9uc2UgY29kZTogNDA0LCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSlcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXNvbHZlIHJlbGF0aXZlIFVSTHNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvOjEwODAvZmlsZXMvXCJcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW86MTA4MC9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIkxvY2F0aW9uXCI6IFwiLy9sb2NhbGhvc3QvdXBsb2Fkcy9mb29cIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly9sb2NhbGhvc3QvdXBsb2Fkcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHA6Ly9sb2NhbGhvc3QvdXBsb2Fkcy9mb29cIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB1cGxvYWQgYSBmaWxlIGluIGNodW5rc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBjaHVua1NpemU6IDcsXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKSxcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZTogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uQ2h1bmtDb21wbGV0ZVwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDExKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcIi91cGxvYWRzL2JsYXJnaFwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDcpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDdcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSg3KTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNCk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDcsIDcsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNCwgMTEsIDExKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGFkZCB0aGUgb3JpZ2luYWwgcmVxdWVzdCB0byBlcnJvcnNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgcmV0cnlEZWxheXM6IG51bGwsXG4gICAgICAgIG9uRXJyb3I6IHdhaXRhYmxlRnVuY3Rpb24oXCJvbkVycm9yXCIpXG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIEN1c3RvbTogXCJibGFyZ2hcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWQ7XG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKG51bGwpO1xuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogUE9TVCwgdXJsOiBodHRwOi8vdHVzLmlvL3VwbG9hZHMsIHJlc3BvbnNlIGNvZGU6IDUwMCwgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpXCIpO1xuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlcXVlc3QpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVzcG9uc2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVzcG9uc2UuZ2V0SGVhZGVyKFwiQ3VzdG9tXCIpKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgb25seSBjcmVhdGUgYW4gdXBsb2FkIGZvciBlbXB0eSBmaWxlc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpXG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZSgwKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvZW1wdHlcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgbm90IHJlc3VtZSBhIGZpbmlzaGVkIHVwbG9hZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvblByb2dyZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25TdWNjZXNzXCIpLFxuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nXCJcbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZ1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogXCIxMVwiLFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiBcIjExXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJlc3VtZSBhbiB1cGxvYWQgZnJvbSBhIHNwZWNpZmllZCB1cmxcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgdXBsb2FkVXJsOiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIsXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIiksXG4gICAgICAgIGZpbmdlcnByaW50OiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwiZmluZ2VycHJpbnRcIikuYW5kLnJlc29sdmVUbyhcImZpbmdlcnByaW50ZWRcIik7XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICB2YXIgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogM1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMTEgLSAzKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmVzdW1lIGEgcHJldmlvdXNseSBzdGFydGVkIHVwbG9hZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIiksXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uICgpIHt9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgdmFyIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgdXBsb2FkLmFib3J0KCk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDUsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWQ7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIG92ZXJyaWRlIHRoZSBQQVRDSCBtZXRob2RcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgdXBsb2FkVXJsOiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIsXG4gICAgICAgIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogM1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDMpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlgtSFRUUC1NZXRob2QtT3ZlcnJpZGVcIl0pLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAxMVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGVtaXQgYW4gZXJyb3IgaWYgYW4gdXBsb2FkIGlzIGxvY2tlZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICB1cGxvYWRVcmw6IFwiaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWRcIixcbiAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIiksXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsXG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMyAvLyBMb2NrZWRcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZDtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG5ldyBFcnJvcihcInR1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBIRUFELCB1cmw6IGh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkLCByZXNwb25zZSBjb2RlOiA0MjMsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKVwiKSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBlbWl0IGFuIGVycm9yIGlmIG5vIExvY2F0aW9uIGhlYWRlciBpcyBwcmVzZW50ZWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIiksXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsXG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgLy8gVGhlIExvY2F0aW9uIGhlYWRlciBpcyBvbWl0dGVkIG9uIHB1cnBvc2UgaGVyZVxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDFcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgobmV3IEVycm9yKFwidHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogMjAxLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSlcIikpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgdGhyb3cgaWYgcmV0cnlEZWxheXMgaXMgbm90IGFuIGFycmF5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIHtcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL2VuZHBvaW50L1wiLFxuICAgICAgICByZXRyeURlbGF5czogNDRcbiAgICAgIH0pO1xuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcihcInR1czogdGhlIGByZXRyeURlbGF5c2Agb3B0aW9uIG11c3QgZWl0aGVyIGJlIGFuIGFycmF5IG9yIG51bGxcIik7XG4gICAgfSk7XG5cbiAgICAvLyBUaGlzIHRlc3RzIGVuc3VyZXMgdGhhdCB0dXMtanMtY2xpZW50IGNvcnJlY3RseSByZXRyaWVzIGlmIHRoZVxuICAgIC8vIHJlc3BvbnNlIGhhcyB0aGUgY29kZSA1MDAgSW50ZXJuYWwgRXJyb3IsIDQyMyBMb2NrZWQgb3IgNDA5IENvbmZsaWN0LlxuICAgIGl0KFwic2hvdWxkIHJldHJ5IHRoZSB1cGxvYWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oXCJvblN1Y2Nlc3NcIilcbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MjNcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMCxcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogMTFcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA5XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDAsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBub3QgcmV0cnkgaWYgdGhlIGVycm9yIGhhcyBub3QgYmVlbiBjYXVzZWQgYnkgYSByZXF1ZXN0XCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogbmV3IFRlc3RIdHRwU3RhY2soKSxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKCkge31cbiAgICAgIH07XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25TdWNjZXNzXCIpO1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkVycm9yXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICBzcHlPbih1cGxvYWQsIFwiX2NyZWF0ZVVwbG9hZFwiKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBhd2FpdCB3YWl0KDIwMCk7XG5cbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcImN1c3RvbSBlcnJvclwiKTtcbiAgICAgIHVwbG9hZC5fZW1pdEVycm9yKGVycm9yKTtcblxuICAgICAgZXhwZWN0KHVwbG9hZC5fY3JlYXRlVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvcik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzdG9wIHJldHJ5aW5nIGFmdGVyIGFsbCBkZWxheXMgaGF2ZSBiZWVuIHVzZWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgb25FcnJvcjogd2FpdGFibGVGdW5jdGlvbihcIm9uRXJyb3JcIilcbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uU3VjY2Vzc1wiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICAvLyBUaGUgZXJyb3IgY2FsbGJhY2sgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciB0aGUgZmlyc3QgZXJyb3IgcmVzcG9uc2UuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzdG9wIHJldHJ5aW5nIHdoZW4gdGhlIGFib3J0IGZ1bmN0aW9uIGlzIGNhbGxlZFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTBdLFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkVycm9yXCIpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICBzcHlPbih1cGxvYWQsIFwic3RhcnRcIikuYW5kLmNhbGxUaHJvdWdoKCk7XG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpLFxuICAgICAgICB3YWl0KDEwMClcbiAgICAgIF0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwidGltZWQgb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgc3RvcCB1cGxvYWQgd2hlbiB0aGUgYWJvcnQgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgY2h1bmtTaXplOiA1LFxuICAgICAgICBvbkNodW5rQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkNodW5rQ29tcGxldGVcIikuYW5kLmNhbGxUaHJvdWdoKCk7XG5cbiAgICAgIGxldCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpLFxuICAgICAgICB3YWl0KDIwMClcbiAgICAgIF0pO1xuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJ0aW1lZCBvdXRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzdG9wIHVwbG9hZCB3aGVuIHRoZSBhYm9ydCBmdW5jdGlvbiBpcyBjYWxsZWQgZHVyaW5nIHRoZSBQT1NUIHJlcXVlc3RcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoKSB7fVxuICAgICAgfTtcblxuICAgICAgc3B5T24ob3B0aW9ucywgXCJvbkVycm9yXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gICAgICB2YXIgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICB1cGxvYWQuYWJvcnQoKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCksXG4gICAgICAgIHdhaXQoMjAwKVxuICAgICAgXSk7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKFwidGltZWQgb3V0XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZiBhbiB1cGxvYWQgcHJvY2VlZHNcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludDogXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiLFxuICAgICAgICByZXRyeURlbGF5czogWzEwXSxcbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbihcIm9uU3VjY2Vzc1wiKVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25FcnJvclwiKTtcblxuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCIvZmlsZXMvZm9vXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDAsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDUsXG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDExXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIiwiY29uc3QgeyBnZXRCbG9iIH0gPSByZXF1aXJlKFwiLi9oZWxwZXJzL3V0aWxzXCIpO1xuY29uc3QgdHVzID0gcmVxdWlyZShcIi4uLy4uL1wiKTtcbmNvbnN0IGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xuXG4vLyBUZXN0IHRpbWVvdXQgZm9yIGVuZC10by1lbmQgdGVzdHMgd2hlbiB1cGxvYWRpbmcgdG8gcmVhbCBzZXJ2ZXIuXG5jb25zdCBFTkRfVE9fRU5EX1RJTUVPVVQgPSAyMCAqIDEwMDA7XG5cbmRlc2NyaWJlKFwidHVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgZGVzY3JpYmUoXCJlbmQtdG8tZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpdChcInNob3VsZCB1cGxvYWQgdG8gYSByZWFsIHR1cyBzZXJ2ZXJcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vbWFzdGVyLnR1cy5pby9maWxlcy9cIixcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbm9ubGF0aW46IFwic8WCb8WEY2VcIixcbiAgICAgICAgICAgIG51bWJlcjogMTAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6IFwiaGVsbG8udHh0XCIsXG4gICAgICAgICAgICBmaWxldHlwZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvTWF0Y2goL15odHRwczpcXC9cXC9tYXN0ZXJcXC50dXNcXC5pb1xcL2ZpbGVzXFwvLyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwbG9hZCBVUkw6XCIsIHVwbG9hZC51cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG4gICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZENvbnRlbnQpXG4gICAgICAgIC50aGVuKCh1cGxvYWQpID0+IHtcbiAgICAgICAgICByZXR1cm4gdXBsb2FkLmFib3J0KHRydWUpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1cGxvYWQpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZERlbGV0aW9uKTtcbiAgICB9LCBFTkRfVE9fRU5EX1RJTUVPVVQpO1xuXG4gICAgaXQoXCJzaG91bGQgdXBsb2FkIHRvIGEgcmVhbCB0dXMgc2VydmVyIHdpdGggY3JlYXRpb24td2l0aC11cGxvYWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vbWFzdGVyLnR1cy5pby9maWxlcy9cIixcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbm9ubGF0aW46IFwic8WCb8WEY2VcIixcbiAgICAgICAgICAgIG51bWJlcjogMTAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6IFwiaGVsbG8udHh0XCIsXG4gICAgICAgICAgICBmaWxldHlwZTogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvTWF0Y2goL15odHRwczpcXC9cXC9tYXN0ZXJcXC50dXNcXC5pb1xcL2ZpbGVzXFwvLyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVwbG9hZCBVUkw6XCIsIHVwbG9hZC51cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgICAgdXBsb2FkLnN0YXJ0KCk7XG4gICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZENvbnRlbnQpO1xuICAgIH0sIEVORF9UT19FTkRfVElNRU9VVCk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVXBsb2FkQ29udGVudCh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmdldCh1cGxvYWQudXJsKVxuICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzLmRhdGEpLnRvQmUoXCJoZWxsbyB3b3JsZFwiKTtcblxuICAgICAgcmV0dXJuIHZhbGlkYXRlVXBsb2FkTWV0YWRhdGEodXBsb2FkKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWRNZXRhZGF0YSh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmhlYWQodXBsb2FkLnVybCwge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiVHVzLVJlc3VtYWJsZVwiOiBcIjEuMC4wXCJcbiAgICB9XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgZXhwZWN0KHJlcy5kYXRhKS50b0JlKFwiXCIpO1xuICAgIGV4cGVjdChyZXMuaGVhZGVyc1tcInR1cy1yZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICBleHBlY3QocmVzLmhlYWRlcnNbXCJ1cGxvYWQtb2Zmc2V0XCJdKS50b0JlKFwiMTFcIik7XG4gICAgZXhwZWN0KHJlcy5oZWFkZXJzW1widXBsb2FkLWxlbmd0aFwiXSkudG9CZShcIjExXCIpO1xuXG4gICAgLy8gVGhlIHZhbHVlcyBpbiB0aGUgVXBsb2FkLU1ldGFkYXRhIGhlYWRlciBtYXkgbm90IGJlIGluIHRoZSBzYW1lXG4gICAgLy8gb3JkZXIgYXMgd2Ugc3VibWl0dGVkIHRoZW0gKHRoZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmVcbiAgICAvLyB0aGF0KS4gVGhlcmVmb3JlLCB3ZSBzcGxpdCB0aGUgdmFsdWVzIGFuZCB2ZXJpZnkgdGhhdCBlYWNoIG9uZVxuICAgIC8vIGlzIHByZXNlbnQuXG4gICAgdmFyIG1ldGFkYXRhU3RyID0gcmVzLmhlYWRlcnNbXCJ1cGxvYWQtbWV0YWRhdGFcIl07XG4gICAgZXhwZWN0KG1ldGFkYXRhU3RyKS50b0JlVHJ1dGh5KCk7XG4gICAgdmFyIG1ldGFkYXRhID0gbWV0YWRhdGFTdHIuc3BsaXQoXCIsXCIpO1xuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKFwiZmlsZW5hbWUgYUdWc2JHOHVkSGgwXCIpO1xuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKFwiZmlsZXR5cGUgZEdWNGRDOXdiR0ZwYmc9PVwiKTtcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQ29udGFpbihcIm5vbmxhdGluIGM4V0NiOFdFWTJVPVwiKTtcbiAgICBleHBlY3QobWV0YWRhdGEpLnRvQ29udGFpbihcIm51bWJlciBNVEF3XCIpO1xuICAgIGV4cGVjdChtZXRhZGF0YS5sZW5ndGgpLnRvQmUoNCk7XG5cbiAgICByZXR1cm4gdXBsb2FkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVVcGxvYWREZWxldGlvbih1cGxvYWQpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPT09IDQwNDtcbiAgfTtcblxuICByZXR1cm4gYXhpb3MuZ2V0KHVwbG9hZC51cmwsIHsgdmFsaWRhdGVTdGF0dXM6IHZhbGlkYXRlU3RhdHVzIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgZXhwZWN0KHJlcy5zdGF0dXMpLnRvQmUoNDA0KTtcblxuICAgICAgcmV0dXJuIHVwbG9hZDtcbiAgICB9KTtcbn1cbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgd2FpdCwgZ2V0QmxvYiB9ID0gcmVxdWlyZShcIi4vaGVscGVycy91dGlsc1wiKTtcbmNvbnN0IHR1cyA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5cbmRlc2NyaWJlKFwidHVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgZGVzY3JpYmUoXCJwYXJhbGxlbCB1cGxvYWRpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIGl0KFwic2hvdWxkIHRocm93IGlmIGluY29tcGF0aWJsZSBvcHRpb25zIGFyZSB1c2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgdmFyIHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIHtcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHVwbG9hZFVybDogXCJmb29cIlxuICAgICAgfSk7XG4gICAgICBleHBlY3QodXBsb2FkLnN0YXJ0LmJpbmQodXBsb2FkKSkudG9UaHJvd0Vycm9yKFwidHVzOiBjYW5ub3QgdXNlIHRoZSB1cGxvYWRVcmwgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGVuYWJsZWRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBzcGxpdCBhIGZpbGUgaW50byBtdWx0aXBsZSBwYXJ0cyBhbmQgY3JlYXRlIGFuIHVwbG9hZCBmb3IgZWFjaFwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuXG4gICAgICBjb25zdCB0ZXN0VXJsU3RvcmFnZSA9IHtcbiAgICAgICAgYWRkVXBsb2FkOiAoZmluZ2VycHJpbnQsIHVwbG9hZCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChmaW5nZXJwcmludCkudG9CZShcImZpbmdlcnByaW50ZWRcIik7XG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC51cGxvYWRVcmwpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnNpemUpLnRvQmUoMTEpO1xuICAgICAgICAgIGV4cGVjdCh1cGxvYWQucGFyYWxsZWxVcGxvYWRVcmxzKS50b0VxdWFsKFtcbiAgICAgICAgICAgIFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCIsXG4gICAgICAgICAgICBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwidHVzOjpmaW5nZXJwcmludGVkOjoxMzM3XCIpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVVcGxvYWQ6ICh1cmxTdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVybFN0b3JhZ2VLZXkpLnRvQmUoXCJ0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzdcIik7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsIFwicmVtb3ZlVXBsb2FkXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuICAgICAgc3B5T24odGVzdFVybFN0b3JhZ2UsIFwiYWRkVXBsb2FkXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYihcImhlbGxvIHdvcmxkXCIpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVybFN0b3JhZ2U6IHRlc3RVcmxTdG9yYWdlLFxuICAgICAgICBzdG9yZUZpbmdlcnByaW50Rm9yUmVzdW1pbmc6IHRydWUsXG4gICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiB0cnVlLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbIDEwIF0sXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEN1c3RvbTogXCJibGFyZ2hcIlxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGZvbzogXCJoZWxsb1wiXG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oKSxcbiAgICAgICAgZmluZ2VycHJpbnQ6ICgpID0+IFByb21pc2UucmVzb2x2ZShcImZpbmdlcnByaW50ZWRcIilcbiAgICAgIH07XG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uUHJvZ3Jlc3NcIik7XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpO1xuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDUpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJwYXJ0aWFsXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoXCJibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1MZW5ndGhcIl0pLnRvQmUoNik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUNvbmNhdFwiXSkudG9CZShcInBhcnRpYWxcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU1ldGFkYXRhXCJdKS50b0JlVW5kZWZpbmVkKCk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDJcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG5cbiAgICAgIC8vIEFzc2VydCB0aGF0IHRoZSBVUkxzIGhhdmUgYmVlbiBzdG9yZWQuXG4gICAgICBleHBlY3QodGVzdFVybFN0b3JhZ2UuYWRkVXBsb2FkKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKFwiYmxhcmdoXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtT2Zmc2V0XCJdKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDJcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoXCJibGFyZ2hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVHVzLVJlc3VtYWJsZVwiXSkudG9CZShcIjEuMC4wXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbVwiKTtcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpO1xuXG4gICAgICAvLyBSZXR1cm4gYW4gZXJyb3IgdG8gZW5zdXJlIHRoYXQgdGhlIGluZGl2aWR1YWwgcGFydGlhbCB1cGxvYWQgaXMgcHJvcGVybHkgcmV0cmllZC5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwXG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiAxMSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogMFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZShcImJsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLU9mZnNldFwiXSkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoNik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBPU1RcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZShcImJsYXJnaFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZShcImZvbyBhR1ZzYkc4PVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLnJlbW92ZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZW1pdCBlcnJvciBmcm9tIGEgcGFydGlhbCB1cGxvYWRcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKTtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAyLFxuICAgICAgICByZXRyeURlbGF5czogbnVsbCxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiLFxuICAgICAgICBvbkVycm9yOiB3YWl0YWJsZUZ1bmN0aW9uKFwib25FcnJvclwiKVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDUpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVyciA9IGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkO1xuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogUE9TVCwgdXJsOiBodHRwczovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiA1MDAsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKVwiKTtcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXF1ZXN0KS50b0JlKHJlcSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXN1bWUgdGhlIHBhcnRpYWwgdXBsb2Fkc1wiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICAvLyBUaGUgY2xpZW50IHNob3VsZCByZXN1bWUgdGhlIHBhcmFsbGVsIHVwbG9hZHMsIGV2ZW4gaWYgaXQgaXMgbm90XG4gICAgICAgIC8vIGNvbmZpZ3VyZWQgZm9yIG5ldyB1cGxvYWRzLlxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDEsXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbigpXG4gICAgICB9O1xuICAgICAgc3B5T24ob3B0aW9ucywgXCJvblByb2dyZXNzXCIpO1xuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcblxuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZCh7XG4gICAgICAgIHVybFN0b3JhZ2VLZXk6IFwidHVzOjpmaW5nZXJwcmludDo6MTMzN1wiLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZFVybHM6IFtcbiAgICAgICAgICBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMVwiLFxuICAgICAgICAgIFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCJcbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMVwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiA1LFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiAyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJIRUFEXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtTGVuZ3RoXCI6IDYsXG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDFcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMyk7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUEFUQ0hcIik7XG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtQ29uY2F0XCJdKS50b0JlKFwiZmluYWw7aHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxIGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiTG9jYXRpb25cIjogXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZDtcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDNcIik7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg1LCAxMSk7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgYWJvcnQgYWxsIHBhcnRpYWwgdXBsb2FkcyBhbmQgcmVzdW1lIGZyb20gdGhlbVwiLCBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHNcIixcbiAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbigpLFxuICAgICAgICBmaW5nZXJwcmludDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFwiZmluZ2VycHJpbnRlZFwiKVxuICAgICAgfTtcbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25Qcm9ncmVzc1wiKTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDUpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJwYXJ0aWFsXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlR1cy1SZXN1bWFibGVcIl0pLnRvQmUoXCIxLjAuMFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJVcGxvYWQtTGVuZ3RoXCJdKS50b0JlKDYpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJwYXJ0aWFsXCIpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1NZXRhZGF0YVwiXSkudG9CZVVuZGVmaW5lZCgpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcTEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXExLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMVwiKTtcbiAgICAgIGV4cGVjdChyZXExLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcTEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxMS5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxMS5ib2R5LnNpemUpLnRvQmUoNSk7XG5cbiAgICAgIGNvbnN0IHJlcTIgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEyLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEyLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuICAgICAgZXhwZWN0KHJlcTIucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1PZmZzZXRcIl0pLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVxMi5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG4gICAgICBleHBlY3QocmVxMi5ib2R5LnNpemUpLnRvQmUoNik7XG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpO1xuXG4gICAgICByZXExLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEyLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBObyBmdXJ0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSBzZW50LlxuICAgICAgY29uc3QgcmVxUHJvbWlzZSA9IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcmVxUHJvbWlzZSxcbiAgICAgICAgd2FpdCgxMDApXG4gICAgICBdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoXCJ0aW1lZCBvdXRcIik7XG5cbiAgICAgIC8vIFJlc3RhcnQgdGhlIHVwbG9hZFxuICAgICAgdXBsb2FkLnN0YXJ0KCk7XG5cbiAgICAgIC8vIFJldXNlIHRoZSBwcm9taXNlIGZyb20gYmVmb3JlIGFzIGl0IGlzIG5vdCBjYW5jZWxsZWQuXG4gICAgICByZXEgPSBhd2FpdCByZXFQcm9taXNlO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDFcIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkhFQURcIik7XG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBcIlVwbG9hZC1MZW5ndGhcIjogNSxcbiAgICAgICAgICBcIlVwbG9hZC1PZmZzZXRcIjogNVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMlwiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiSEVBRFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLUxlbmd0aFwiOiA2LFxuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA2XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cHM6Ly90dXMuaW8vdXBsb2Fkc1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbXCJUdXMtUmVzdW1hYmxlXCJdKS50b0JlKFwiMS4wLjBcIik7XG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzW1wiVXBsb2FkLUxlbmd0aFwiXSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1tcIlVwbG9hZC1Db25jYXRcIl0pLnRvQmUoXCJmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJMb2NhdGlvblwiOiBcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkM1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkO1xuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShcImh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkM1wiKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSk7XG4gICAgfSk7XG4gIH0pO1xufSk7IiwiLyogZ2xvYmFsIGV4cGVjdEFzeW5jICovXG5jb25zdCB7IFRlc3RIdHRwU3RhY2ssIGdldEJsb2IgfSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvdXRpbHNcIik7XG5jb25zdCB0dXMgPSByZXF1aXJlKFwiLi4vLi4vXCIpO1xuXG5kZXNjcmliZShcInR1c1wiLCBmdW5jdGlvbiAoKSB7XG4gIGRlc2NyaWJlKFwidGVybWluYXRlIHVwbG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaXQoXCJzaG91bGQgdGVybWluYXRlIHVwbG9hZCB3aGVuIGFib3J0IGlzIGNhbGxlZCB3aXRoIHRydWVcIiwgYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGFib3J0UHJvbWlzZTtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgZmlsZSA9IGdldEJsb2IoXCJoZWxsbyB3b3JsZFwiKTtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQ6IFwiaHR0cDovL3R1cy5pby9maWxlcy9cIixcbiAgICAgICAgY2h1bmtTaXplOiA1LFxuICAgICAgICBvbkNodW5rQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhYm9ydFByb21pc2UgPSB1cGxvYWQuYWJvcnQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsIFwib25DaHVua0NvbXBsZXRlXCIpLmFuZC5jYWxsVGhyb3VnaCgpO1xuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKTtcbiAgICAgIHVwbG9hZC5zdGFydCgpO1xuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQT1NUXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246IFwiL2ZpbGVzL2Zvb1wiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIlBBVENIXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgXCJVcGxvYWQtT2Zmc2V0XCI6IDVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL2Zvb1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiREVMRVRFXCIpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgYXdhaXQgYWJvcnRQcm9taXNlO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmV0cnkgdGVybWluYXRlIHdoZW4gYW4gZXJyb3IgaXMgcmV0dXJuZWQgb24gZmlyc3QgdHJ5XCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBhYm9ydFByb21pc2U7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpO1xuICAgICAgdmFyIGZpbGUgPSBnZXRCbG9iKFwiaGVsbG8gd29ybGRcIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50OiBcImh0dHA6Ly90dXMuaW8vZmlsZXMvXCIsXG4gICAgICAgIGNodW5rU2l6ZTogNSxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYWJvcnRQcm9taXNlID0gdXBsb2FkLmFib3J0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzcHlPbihvcHRpb25zLCBcIm9uQ2h1bmtDb21wbGV0ZVwiKS5hbmQuY2FsbFRocm91Z2goKTtcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucyk7XG4gICAgICB1cGxvYWQuc3RhcnQoKTtcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpO1xuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoXCJodHRwOi8vdHVzLmlvL2ZpbGVzL1wiKTtcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKFwiUE9TVFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiBcIi9maWxlcy9mb29cIlxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCk7XG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZShcImh0dHA6Ly90dXMuaW8vZmlsZXMvZm9vXCIpO1xuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoXCJQQVRDSFwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIFwiVXBsb2FkLU9mZnNldFwiOiA1XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MjNcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiAyMDRcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBhYm9ydFByb21pc2U7XG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHN0b3AgcmV0cnlpbmcgd2hlbiBhbGwgZGVsYXlzIGFyZSB1c2VkIHVwXCIsIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKCk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIHJldHJ5RGVsYXlzOiBbMTAsIDEwXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdGVybWluYXRlUHJvbWlzZSA9IHR1cy5VcGxvYWQudGVybWluYXRlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIiwgb3B0aW9ucyk7XG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKTtcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKFwiaHR0cDovL3R1cy5pby9maWxlcy9mb29cIik7XG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZShcIkRFTEVURVwiKTtcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3RBc3luYyh0ZXJtaW5hdGVQcm9taXNlKS50b0JlUmVqZWN0ZWRXaXRoRXJyb3IoL3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSB0ZXJtaW5hdGluZyB1cGxvYWQvKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdfQ==
